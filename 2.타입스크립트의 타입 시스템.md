# Effective - #2장 타입스크립트의 타입 시스템

![327754-eng](https://user-images.githubusercontent.com/34502254/166692339-dad60070-d050-4f7e-8429-a3c197a2d55a.png)

# 2장 타입스크립트의 타입 시스템

## 아이템 6

**편집기를 사용하여 타입 시스템 탐색하기**

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용할때에는 에디터에서 코드자동완성, 명세, 검사, 검색, 리팩토링이 가능하다.

마우스를 호버 하고 해당하는 타입이 무엇인지 확인이 가능하다.

![스크린샷_2022-05-04_오후_10 09 44](https://user-images.githubusercontent.com/34502254/166692374-1657a848-87a2-4289-a087-a0d486c0f099.png)

타입이 기대한것과 다르다면 명시적으로 선언이 가능하고, 실제 문제가 발생하는 곳을 찾아볼 수 있다.

객체의 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지도 살펴보는것이 좋다.

라이브러리 혹은 api의 타입이 궁금하다면 해당 노드모듈로 이동해서 타입을 확인하는 방법도 있다.

## 아이템 7

**타입이 값들의 집합이라고 생각하기**

코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있고, 할당 가능한 값들의 집합이 타입이라고 생각하면 된다.

해당한 이 집합은 타입의 범위라고 부르기도 한다.

타입스크립트에서 유닛 타입이라고 불리우는 리터럴 타입

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온타입을 사용한다.

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

`|`  으로 또는 이라는 타입을 선언할 수 있다.

![스크린샷_2022-05-04_오후_10 20 14](https://user-images.githubusercontent.com/34502254/166692396-796d4f9f-08ca-4a7d-9679-9987fb4ef0d9.png)

인터페이스는 구조적 타이핑 규칙에 의해 어떠한 값이 다른 속성도 가질 수 있음을 의미한다. 

집합의 느낌을 살려, extends키워드를 사용하여 ~에 할당 가능하도록 한다 라는 의미로서 집합이라는 의미로 받아들일 수 있다.

![스크린샷_2022-05-04_오후_10 22 56](https://user-images.githubusercontent.com/34502254/166692422-6273daf7-4658-4431-b591-977bf1004528.png)


상속한다는 의미를 객체 상속의 관점으로 생각한다면 어렵다. 하나의 타입안에 집합 범위라고 생각하여 이를 쉽게 이해 할 수 있게한다.

![스크린샷_2022-05-04_오후_10 31 50](https://user-images.githubusercontent.com/34502254/166692437-1302ea2b-2159-4d70-831e-09d569290332.png)


- 타입스크립트 타입은 엄격한 상속 관계가 아니라. 겹쳐지는 집합으로 표현된다.
- 집합은 유한하거나 무한하다.

## 아이템 8

**타입 공간과 값 공간의 심벌 구분하기**

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

심벌은 이름이 같더라도 속하는 공간에 따라 다른것을 나타낼 수 있다.

instanceof 를 이용하여 타입이 무엇인지 확인하는지 가능하나. 값에 대해 연산을 하기 때문에 함수를 참조하게 된다.

두가지 타입이 있다면, typeof를 사용하는 상황에 따라 다르게 동작할 수 있다.

- as OOO 라고 붙이게 된다면 리터럴 또는 리터럴 표현식이 추론된 타입을 바꾸게 된다.
- extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의 할 수 있다.
    - Generic<T extends number>
- in은 루프 또는 매핑된 타입에 등장하게 된다.

자바스크립트에서 구조 분해 할당이 가능하지만 타입스크립트에서 구조분해 할당으로 적게된다면, 오류가 발생할 수 있다.

그러므로 interface를 사용하거나 type을 미리 정의해 주어 타입을 정의해 주어야 한다.

```tsx
function Email(
 {person, subject, body} : 
 {person:Person, subject: string, body : string}
) {
	...
}
```

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용된다.

## 아이템 9

**타입 단언보다는 타입 선언을 사용하기**

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두가지이다.

```tsx
interface Person {name : string};

const alice: Person = {name : "Alice"}; // 타입 Person
const bob = {name : "Bob"} as Person    // 타입 Person
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.

> const bob = <Person>{} 단언문의 문법이며 , {} as Person 과 동일하다.
> 

타입 단언을 사용하면 런타임에 문제가 발생할 수도 있다. 

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 단언문을 사용하는건은 타당한 방법이다.

- 타입 단언의 as Type 보단  : Type 의 타입 선언을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 잇는 상황에서는 타입 단언문과 null 아님 단언문을 사용한다. ( person! )

## 아이템 10

**객체 래퍼 타입 피하기**

charAt 는 몇번째의 타입을 찾아낼수도 있고 그 타입이라고 정의할 수도 있다.

.charAt(0) 이런식이나 , .charAt(3) 이런식으로 하면 0번 이나 3번의 타입을 알게됨

타입을 정의할때 래퍼 객체는 타입의 구문의 첫 글자를 대문자로 표기하는 방법으로 사용한다. 그러나 타입스크립트 객체 래퍼 타입은 지양하고 기본형 타입을 사용하는것을 권장한다.

## 아이템 11

**잉여 속성 체크의 한계 인지하기**

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립는 해당 타입의 속서이 있는지 그리고 그외의 속성이 없는지 확인한다.

잉여속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워지기에, 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입 시스템에 대한 개념을 잡을 수 있다.

document 나 new HTMLAnchorElement는 객체 리터럴이 아니기 때문에 잉여 속성 체크가 되지 않는다.

잉여 속성 체크는 타입 단언문을 사용할 때에도 적용되지 않습니다.

```tsx
const foo = {x : true , y : "Jang" } as Name ; // 정상
```

잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

구조적 관점에서 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.

공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않습니다.

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름이 오타 같은 실수를 잡는데 효과적인 방법이다.

잉여 속성 체크에는 한계가 있어, 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템 12

**함수 표현식에 타입 적용하기**

자스와 타스에서는 함수 문장과 함수 표현식을 다르게 인식한다.

타입스크립트에서는 함수 표현식을 사용하는 것이 좋으며, 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.

```tsx
type DiceRollFn = (sides :number ) => number;
const rollDice : DiceRollFn = sides => { ... };
```

함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다.
- 다른 함수의 시그니처를 참조하려면 typeof 함수 를 사용하면 된다.

## 아이템 13

**타입과 인터페이스의 차이점 알기**

명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임의 개념이다.

명명된 타입을 정의해 일관성을 유지해야 한다.

- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 타입은 인터페이스를 확장할 수 있다.
- 인터페이스는 타입을 확장할 수 있지만 유니온은 할 수 없다.
- 인터페이스로도 튜플과 비슷하게 구현할 수 있기는 하다.
