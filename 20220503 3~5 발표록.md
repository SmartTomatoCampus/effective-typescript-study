# 5월 3일 화 1.3 ~ 1.5 발표록

# 꽁치

1. 타입은 런타임에 접근 불가하지만, 값은 런타임에 접근이 가능하다. 때문에 코드 내에서 타입을 명시적으로 참조하면 에러가 날 수 있다. 때문에 특정 타입의 값이 어떤 속성을 가지고 있는지 체크하거나, 타입 정보를 명시적으로 저장하는 '태그' 기법을 사용하거나, 인터페이스를 클래스로 선언해 참조한다.
2. 타입 연산은 어떠한 정제작용도 못하고 런타임에 영향을 주지 못 하기 때문에 타입을 실제로 변환하는 것은 자바스크립트 연산을 해야한다.
3. 타입스크립트의 함수 오버로딩은 타입으로만 함수 오버로딩이 가능하고, 구현체는 오직 하나여야 한다.
4. 타입스크립트의 타입은 열려있다. 즉, 실제 요구되는 인터페이스와 다르더라도 요구하는 속성을 가지고 있다면 해당 인터페이스도 받을 순 있다.
5. any 는 최대한 지양하자

# 뽀또

- 유닛테스트
- any 사용 지향
- 구조적 타이핑에 익숙해지기
- 유니온 기법

# 너두

# 코드 생성과 타입이 관계없음을 이해했음

여담이지만 오늘 하루종일 코드는 돌아가는데 타입에러나는 현상을 경험함.

- 구버전 자바스크립트로 트랜스파일링 한다
- 코드의 타입 오류를 체크한다

엉성해보이지만 타입체크오류와 별개로 빌드가 가능한게 왜 도움이 되냐면 해결 못하는 타입도 있기 때문입니다. 오늘 치트키 any 한개 써버렸습니다.

인사이트를 얻었습니다

```tsx
interface Square {
  width: number
}
interface Rectangle extends Square {
  height: number
}
type Shape = Square | Rectangle
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape // Type is Rectangle
    return shape.width * shape.height
  } else {
    shape // Type is Square
    return shape.width * shape.width
  }
}

export default {}
```

코드에서 보면 any를 쓴부분에 이걸 사용하면 해결이 될것같다는 기분을 느꼈습니다

이것도 사용할 수 있을것 같습니다

```tsx
class Square {
  constructor(public width: number) {}
}
class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width)
  }
}
type Shape = Square | Rectangle

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    shape // Type is Rectangle
    return shape.width * shape.height
  } else {
    shape // Type is Square
    return shape.width * shape.width // OK
  }
}

export default {}
```

**타입연산은 런타임과 성능에 영향을 주지 않습니다**

**타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다 하지만 타입을 오버로드 할수 있습니다**

# 구조적 타이핑에 익숙해지기

- x y가 2D와 호환되는 이슈가 타입체커가 문제로 인식하지 않음

# any타입 지양하기

# 애한

# item 3 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러는 2가지 역할을 수행

1. 최신 타입스크립트/ 자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
2. 코드 타입의 오류를 체크

2가지 역할이 독립적으로 수행되기 때문에 `타입 오류가 있는 코드도 컴파일이 가능`하고, `런타임에는 타입 체크가 불가능`하다.

- type이 뭐야...?

객체의 타입의 이름을 지정하는 방법

- interface가 뭐야...?

객체의 타입의 이름을 지정하는 또 다른 방법
- 그 2개의 차이는 뭐야?

interface는 선언 병합이 가능하지만 type은 그렇지 않음

computed value의 사용 - type은 가능하지만 interface는 불가능
- interface는 객체에만 사용이 가능하다.

p.15 instanceof 체크는 런타임에 일어나지만, Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없다. 타입스크립트의 타입은 제거가능하다. ??

p.16 타입과 값을 둘다 사용하려면 타입을 클래스로 만들면 된다?

- 타입 연산은 런타임에 영향을 주지 않는다.
- 런타임 타입은 선언된 타입과 다를 수 있다

p.19 /light를 요청하면 그 결과로 LightApiResponse를 반환하라고 선언햇지만 실제로 그렇게 되리라는 보장은 없다. API를 잘못 파악해서 ligthSwitch Value가 실제로는 문자열이었다면 런타임에는 setLightSwitch함수까지 전달될 것.(??)

- 타입스크립트 타입으로는 함수를 오버로드할 수 없다.
  -> 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작. 하나의 함수에 대해 여러개의 선언문을 작성할 수 잇지만 구현체는 오직 하나뿐

- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

p.20 빌드타임 오버헤드란 무엇인가?

오버헤드가 터지면 빌드도구에서 트랜스파일만을 설정하여 타입체크를 건너 뛸 수 있다.
타입스크립트가 컴파일하는 코드는 오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안할지, 호환성을 포기하고 성능 중심의 네이티브 구현체를 선택할지 문제에 맞닥뜨릴 수도 있다.

# item 4 구조적 타이핑에 익숙해지기

javascript는 `덕 타이핑(duck typing)`기반이다.

타입은 봉인되어있지 않다.?? -> 오픈되어있다.

클래스도 구조적 타이핑 규칙을 따른다. 클래스의 인스턴스가 예상과 다를 수 있다.

구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.?

p.26 모킹 라이브러리??
p.26 라이브러리 간의 의존성을 분리한다는 것이 무엇인가?

# item 5 any타입 지양하기

타입스크립트의 타입시스템은 점진적이고 선택적.

타입을 조금씩 추가할 수 있기 때문에 점진적이고, 언제든지 타입체커를 해제할 수 있기 때문에 선택적.

1. any 타입에는 안전성이 없다.
2. any는 함수 시그니처를 무시해버린다
3. any 타입에는 언어서비스가 적용되지 않는다
4. any타입은 코드 리팩터링 때 버그를 감춘다.
5. any 타입 설계를 감춰버린다
6. any는 타입 시스템의 신뢰도를 떨어뜨린다.

그러므로 최대한 사용을 피하자.

# 삼앵

- 자바스크립트 에러는 컴파일시 빌드가 되지않지만 타입스크립트 컴파일 오류는 문제가될만한 부분을 알려주지만, 그렇다고 빌드를 멈추지않습니다. (해당부분 저도 좀 궁금)
- 타입정보를 유지하고 런타임에 접근가능한 타입정보 저장'태그'기법

1. interface커스텀 타입으로 사용되며 인터페이스에는 필수 항목으로 사용할 프로퍼티를 선언해서, 함수에 전달하는 인자의 형식을 고정할 수 있습니다. 이 경우는 인터페이스를 인자로 받는 함수가 실행될 때 TypeScript 컴파일러가 인자의 유효성을 먼저 검사합니다.

2. 추상클래스로 사용됩니다. 메소드의 형태만 선언해서 인터페이스를 정의하고, 이후에 클래스를 정의할 때 implements 키워드를 사용하면서 이 인터페이스를 지정하면, 이 클래스는 추상함수로 선언된 메소드의 몸체를 받아들여야 합니다.

3.  Interface를 사용하는 경우 : 코드에서 둘 이상의 위치, 특히 둘 이상의 파일 또는 함수에서 사용될 객체의 속성 및 함수를 생성해야하는 경우에 사용합니다. 특정 유형의 객체들이 동일한 속성을 가지고 있을때 Interface를 통해 이를 쉽게 구현할 수 있습니다.

1. 타입스크립트 or class 사용하기 타입을 클라스로 만들면 타입과 을 둘다 사용할수있습니다. 1. class는 객체 저장공간으로 사용됩니다. Class는 객체의 모양과 동작을 정의하여 다음 클래스 속성을 초기화하고 method를 정의합니다. 따라서 클래스의 인스턴스를 만들 때 실행 가능한 함수와 정의된 property를 가진 객체를 얻습니다
2. class를 사용할때에는 타입 체크 뿐만 아니라 constructor 또는 함수의 구현를 원할 때는 Class를 사용하는 것이 옳습니다. 객체를 만들다보면 초기화를 위한 constructor이 있는 경우가 있습니다. 이 경우에는 Class를 사용해야합니다.
3. 요약 타입스크립트는 자바스크립트의 덕타이핑을 모델링하기위해 구조적 타이핑을 사용한다는것을 이해해야합니다.(저도 미숙)

### ANY 타입 지양하기

- 타입스크립트의 타입 시스템은 점진적이고 선택적입니다 코드에 타입을 조금씩 추가할수있기 떄문에 점진적이며 언제든지 타입체커를 해제할수있기에 선택적입니다. 이와같은 기능들의 핵심이 ANY 타입니다.
1. any 타입에는 안전성이 없기떄문에 age를 number 타입을 선언되었으나 as any를 사용하면 읽어오는것에는 문제는없으나 string으로 타입을 할당될수있다 타입체커는 선언에따라 판단할것이고 혼란스러운 결과가 나올수있습니다.

# 로록

1. interface 의 존재 자체를 알게 됐다.
2. 타입스크립트의 타입은 런타임 시점에는 소멸된다.
3. 타입스크립트의 타입은 열려있다.

# 명성

코드 생성은 타입과 무관하다.
타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않는다.
타입 오류가 존재해도 컴파일은 별도의 기능이기에 컴파일은 별도로 진행된다.

타입스크립트의 타입은 런타임에 사용할 수 없다.

일반적으로 태그된 유니온과 속성 체크 방법으로 타입정보를 유지한다
또한 클래스같이 타스의 타입과 런타임 값 둘다를 제공하는 방법도 있다.

타스가 생성하는 코드는 오래된 런타임환경을 지원하기위해
성능오버헤드를 감안할지
호환성을 포기하고 성능중심으로 구현할지 선택해야하는 문제를 마주할 수 있다.
하지만 어떤 경우든지 호환성과 성능 사이의 선택은 코드생성타겟과 언어 레벨의 문제이지 타입과는 무관하다.


덕 타이핑기반
어떤 함수의 매개변수 값이 모두 제대로 주어진다면 그 값이 어디서 왔는지 신경쓰지 않고 사용.

자스의 이런 동작을 타스도 그대로 모델링한다.

다만 타입체커의 타입이해도가 사람과는 다르기에 가끔 예상치 못한 결과가 나온다.

그렇기에 구조적 타이핑을 제대로 이해하여 오류를 구별하고 견고한 코드를 작성해야한다.