# 뽀또

## 아이템 26

**타입 추론에 문맥이 어떻게 사용되는지 이해하기**

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지는 않는다.

값이 존재하는 문맥까지도 살피게 되는데 문맥을 고려해 타입을 추론하면 가끔 이상하기에, 타입 추론이 어떻게 사용되는지 이해도가 필요하다.

```tsx
let language : Language = "JavaScript";
setLanguage(language)
```

```tsx
const language = "JavaScript";
setLanguage(language)
```

상수나, 타입선언을 통하여 해당 타입에 문자열 리터럴을 제공함으로써, 타입체커에게 정확한 타입을 제공할수 있게 해준다.

그러나 이것을 재할당을 하기 위해서는 타입 선언이 필요하다. 이 타입선언을 하기 위해서는 문맥을 분리해야 하는데, 문맥을 분리하게 되면 추후 근본적인 문제를 발생시킬 수 있다.

튜플 타입에서도 문맥과 값을 분리할 경우 타입 문제가 생기게 된다. 이를 해결할 수 있는 방법은. any가 있지만, const를 사용하여 선언하게 된다면 오류를 고칠 수 있으며, as const 를 통해 깊은 복사 개념을 활용한 상수라는 개념을 타입스크립트에 알려주면 된다.

```tsx
const loc = [ 10, 20 ] as const;
panTo(loc);
// ~~~ readonly [10, 20] 형식은 readonly 이며
// 변경 가능한 형식 [ number ,number ] 에 할당할 수 없다.
```

이 방식은 타입을 readonly 로 추론되기에, 다른 방법을 적용해야 한다.

```tsx
function panTo(where : readonly [number, number]) {... }
const loc = [10 , 20] as const;
panTo(loc) // 정상
```

타입 시그니처를 수정할 수 없는 경우라면 타입 구문을 사용해야 한다.

as const는 문맥 손실과 관련한 문제를 깔끔하게 해결할 수 있지만, 한가지 단점을 가지고 있다. 만약 타입 정의에 실수가 있다면, 오류는 타입 정의가 아니라 호출되는 곳에서 발생하는 것이다.

> **이러한 오류는 근본적인 원인을 파악하기 힘들다.**
> 

- 객체 사용 시에도 문맥에서 값과 분리하는 과정에서 문제가 발생될 수 있다.
- 콜백시에도 다른 함수로 전달할때, 타입스크립트는 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다.
- 타입 추론에서 문맥이 어떻게 사용되는지 확인해야한다.
- 변수가 정말로 상수라면 상수 단언(as const)를 사용해야 한다.
    - 상수 단언은 사용한 곳에서 오류가 발생되기에 사용한 곳에서 오류 체크를 해야한다.
    
    
# 너두

## 아이템 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기

- 타입추론은 단순히 값만 고려하지 않고 문맥까지 살핀다. 그래서 가끔 이상하다.

해결방법

1. 타입을 미리 선언해서 값을 제한한다
2. 상수(const) 값을 쓴다
- 해당 방법은 문맥으로부터 값을 분리한것임. 하지만 근본적인 문제가 발생된다.
- 문자리터럴,튜플 역시 문제가 발생한다.
- any를 사용하지 않고 문제를 안만드는 방법은 상수 문맥을 제공하는것이다
const는 얕은 상수이나 as const는 딥하다. 하지만 너무 과함.
- 최선의 선택은 readonly를 사용하는것이다.
- 문자열이나 튜플을 포함하는 큰 객체에서도 같은 문제가 발생한다
- 객체에서 결국 타입선언이나 상수 단언을 사용해서 해결한다
- 콜백 사용시 매개변수에 타입구문을 추가해야한다.

# 삼앵

## 아이템26 타입추론에 문맥이 어떻게 사용되는지 이해하기

- 타입스크립트는 문맥에 따라 타입 추론을 다르게 한다.
- let과 const 키워드의 타입 추론의 결과값이 다르다. const 키워드 사용 시에 더 좁은 타입으로 추론한다.



```tsx
ex) let
let language: Languae ='JavaScript';
setLanguage(language); //string
```


```tsx
ex) const
const language ='JavaScript';
setLanguage(language); //javascript
```

- const 키워드는 얕은 상수 선언이고 as const 키워드는 깊은 상수 선언이다.

# 애한

## item 26 타입 추론에 문맥이 어떻게 사용되는지 이해하기.
타입스크립트는 타입추론시 값만 고려하지 않는다.
자바스크립트는 코드의 동작과 실행 순서를 바꾸지 않으면서 표현식을 상수로 분리가능
(인라인 형태 == 참조형태)

문자열 리터럴 사용시
인라인에서는 타입스크립트는 함수선언을 통해 매개변수의 타입을 알 수 있지만 이를 변수로 분리해내면, 타입스크립트는 할당 시점에 타입을 추론. 때문에 오류가 발생.
이를 해결 하는 방법 :
1. 타입 선언에서 매개변수를 가능한 값 제한
2. 매개변수를 상수로 만드는 것.

튜플 사용시 주의????????
any 사용. 상수문맥 제공. 
as const : 그 값이 내부까지 상수라는 사실을 알려줌
* as const : type assertion의 한 종류로, 리터럴 타입의 추론 범위를 줄이고 값의 재할당을 막기 위한 목적으로 만들어짐.
일반적인 문자열 리터럴인 경우 const로 선언하면 자동적으로 새로운 값을 할당할 수 없는 상수로 추론되지만, 원시타입이 아닌 object나 array 타입이면, 참조타입이기 때문에 const로 선언하더라도 내부 프로퍼티의 추론 범위가 한정되지도 않고 값도 변경될 수 있다. 이 때 as const를 사용(상수단언)하면 객체의 모든 프로퍼티들이 readonly로 변경되고 각 프로퍼티의 타입이 리터럴 값으로 추론된다.
https://velog.io/@logqwerty/Enum-vs-as-const


객체 사용시 주의
타입선언을 추가하거나 상수단언을 이용해 해결

콜백사용시 주의
콜백을 상수로 뽑아내면 문맥이 소실되고 noImplicitAny 오류 발생
noImplicitAny : 암시적으로 선언되었는데 any로 추론될 수 있음?
? 의도적이지 않게 암시적으로 any형식으로 추론될때 표기되는?

음...
타입추론시 문맥이 어떻게 쓰이는지 주의해야한다.(예를 들어 설명, 문자열 리터럴 사용시, 튜플 사용시, 객체 사용시, 콜백 사용시 주의할 점들 ㅇㅇ)
인라인 형태로 사용하는 것과 변수를 뽑아서 별도로 선언하는 것은 결과는 같지만 후자의 경우 오류 발생시 타입 선언을 추가해야한다.
변수가 상수라면 상수 단언을 사용

# 로록

1. 값을 변수로 분리하면 타입스크립트는 할당 시점에 타입을 추론한다.

type Language = 'JavaScript' | 'TypeScript' | 'Python';
function setLanguage(language: Language) {}

setLenguage = 'JavaScript';

let language = 'JavaScript';
setLanguage(language);


- setLenguage = 'JavaScript' ⇒ Language 타입으로 추론
- let language = 'JavaScript' ⇒ 할당 시점이니 string 타입으로 추론

⇒ 이래서 오류난다는 거 같다…!

2. 이런 문제를 해결하는 2가지 방법
- 타입 선언에서 language의 가능한 값 제한

let language:Language = 'JavaScript';


⇒ 요게 타입 정해주는 거 아닌가??

- language를 상수로 만들기

const language = 'JavaScript';


⇒ 할당 가능 여부에 따라 타입 추론되는 게 다른가보다,,,!

3. 튜플 사용 시 주의점

```tsx
#number[] ⇒ 길이를 알 수 없는 number 배열

#[number, number] ⇒ 길이가 2인 number 배열
```

- 배열의 길이가 다르게 타입 추론되면 오류 생김
- 해결방법
    - const loc : [number, number] = [10, 20]
    - 상수 단언 사용 + 함수에 readonly 추가

        ex) const loc = [10, 20] as const;

        ⇒ const는 얕은 상수, as const는 내부까지 상수

4. 객체 사용 시 주의점
- 값을 분리할 때 오류가 나면 타입 선언 추가 또는 상수 단언 사용

5. 콜백을 상수로 뽑아내면 생기는 오류 해결
- 매개변수 타입 구문 추가
- 전체 함수 표현식에 타입 선언

결론

- 변수를 별도로 선언할 때는 타입 선언을 하자.
- 상수라면 상수 단언을 하자.
