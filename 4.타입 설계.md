# Effective - #4장 타입 설계

![327754-eng](https://user-images.githubusercontent.com/34502254/168100406-8929de59-6ccb-4f91-981f-f520586eaf70.png)

## 아이템 28

**유효한 상태만 표현하는 타입을 지향하기**

타입을 잘 설계하면 코드는 직관적으로 작성할 수 있다. 그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못한다.

효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.

- 유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.
- 유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.


## 아이템 29

**사용할 때는 너그럽게, 생성할 때는 엄격하게**

> TCP 구현체는 견고성의 일반적 원칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.
> 

함수의 시그니처에도 비슷한 규칙을 적용해야 한다. 함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.

보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있다.

선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적이다.

매개변수와 반환 타입의 재사용을 위해서 기본 형태와 느슨한 형태를 도입하는 것이 좋다.


## 아이템 30

**문서에 타입 정보를 쓰지 않기**

코드의 주석과 타입의 상태의 표기가 잘못되어있다면 해당 코드는 잘못된 코드라고 생각하게 된다.

값을 변경하지 않는다고 설명한는 주석도 좋지 않으며, 또한 매개변수를 변경하지 않는다는 주석도 사용하지 않는 것이 좋다.

readonly를 사용하여 규칙을 강제할 수 있게 하면 된다.

타입이 명확하지 않은 경우는 변수명에 단위 정보를 포함하는 것을 고려하는 것이 좋다.


## 아이템 31

**타입 주변에 null 값 배치하기**

값이 전부 null 이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때보다 다루기가 쉽다. 

타입에 null을 추가하는 방식으로 이러한 경우를 모델링 할 수 있다.

null 아님 단언 대신 단순 if구문으로 체크할 수도 있다.

null은 2개의 타입이 존재하는 나와 null 인경우에만 사용해야 적극적으로 활용할 수 있다. 타입이 여러개이거나, 속성값이 불확실성한 값이라면 버그를 양산하게 된다.

null 인 경우가 필요한 속성은 프로미스로 바꾸면 안된다. 코드가 복잡해지고 모든 매서드가 비동기로 바뀌어야 한다.


## 아이템 32

**유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기**

```tsx
interface FillLayer {
	layout : FillLayout;
	paint : FillPaint;
}
interface LineLayer {
	layout : LineLayout;
	paint : LinePaint;
}
interface PointLayer {
	layout : PointLayout;
	paint : PointPaint;
}

type Layer = FillLayer | LineLayer | PointLayer
```

- 타입의 속성들 간에 관계를 재대로 모델링하면, 타입스크립트가 코드의 정확성을 체크하는 데 도움이 된다.
- 타입의 구조를 손 댈 수 없는 상황이면 앞서 다룬 인터페이스의 유니온을 사용해서 속성 사이의 관계를 모델링 할 수 있다.
- 여러개의 선택적 필드가 동시에 값이 있거나 동시에 undefined인 경우도 태그된 유니온 패턴이 잘 맞는다.
- 유니온 타입의 속성을 여러 개 가지는 인터페이스에서는 속성 간의 관계가 분명하지 않기 때문에 실수가 자주 발생한다.

- 유니온의 인터페이스보다 인터페이스의 유니온이 더 정확하고 타입스크립트가 이해하기가 더 좋다.
- 타입스크립트가 제어 흐름을 분석할 수 있도록 타입에 태그를 넣는 것을 고려해야 한다.
- 태그된 유니온은 타입스크립트와 매우 잘 맞기 때문에 자주 볼 수 있는 패턴이다.

## 아이템 33

string 타입보다 더 구체적인 타입 사용하기

string 타입의 범위는 매우 넓기때문에 더 좁은 타입이 있는지 적절한게 있는지 확인을 해봐야 한다.

타입을 더 좁히기 위해서 하나의 타입을 공유한 뒤, 유니온 타입을 통해 타입을 좁힐 수 있지만, enum을 사용할 수도 있지만 추천하는 방향은 아니다.

### 구체적인 타입을 사용하게 되면 좋은점 3가지.

1. 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.
2. 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있다. ( 호버되면 뜨게되는 내용)
3. keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다.

```tsx
T[keyof T] 는 객체 내의 가능한 모든 값의 타입이다.
```

문자열이 여러개 있거나, 확실한 문자열이라면, 문자열 리터럴을 사용해서 유니온 타입으로 지정하고 이를 string이 아닌 keyof T를 이용해 타입을 구체적으로 적용시키자 . 이말인듯 하다.

- 문자열을 남발되어 선언된 코드를 피하자.
- 모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋다.
- 변수의 범위를 보다 정확하게 표현하고 싶다면 문자열 리터럴 타입의 유니온을 사용해라.
- 객체의 속성 이름의 함수 매개변수로 받을 때는 string 보다 keyof T를 사용해라.

## 아이템 34

**부정확한 타입보다는 미완성 타입을 사용하기**

타입선언을 작성하다 보면 코드의 동작을 더 구체적으로 또는 덜 구체적으로 모델링하게 되는 상황을 맞닥뜨리게 된다. 일반적으로 타입이 구체적일수록 버그를 더 많이 잡고 타입스크립트가 제공하는 도구를 활용할 수 있게 된다.

각 함수의 매개변수 개수가 정확한지 확인하기 위해 모든 함수 호출을 확인할 수도 있지만 재귀적으로 동작하기 때문에 좋은 방법은 아니다.

인터페이스를 호출 표현식으로 한번에 묶을 수는 없기 때문에 각 인터페이스를 나열해서 호출 표현식을 작성한다.

고정 길이 배열은 튜플 타입으로 가장 간단히 표현 할 수 있다.

타입을 정의할때 any 같은 추상적인 타입은 정제 하는 것이 좋다.

타입이 구체적으로 정제된다고 해서 정확도가 무조건 올라가지는 않는다. 그러므로 타입에 의존하기 시작하면 부정확함으로 인해 발생하는 문제는 더 커지게 된다.

## 아이템 35

데이터가 아닌, API와 명세를 보고 타입 만들기

잘 설계된 타입은 타입스크립트 사용을 즐겁게 해주는 반면, 잘못 설계된 타입은 비극을 불러오게 되는 양면성 때문에 타입설계를 잘 해야 한다는 압박감을 느껴 질 수 있다.

파일 형식 , API, 명세 등으로 외부에서 받아온 타입은 참고를 하여 타입을 생성 할 수 있다.

restful api를 통해서 받아오는 스키마 형식들은 타입을 지정하기에 매우 편리하게 되어 있어, 스키마를 보고서 작성을 요할 수 있다.

데이터에 의존하는 것보단 명세로부터 코드를 생성하는 것이 좋은 방법이다.

## 아이템 36

**해당 분야의 용어로 타입 이름 짓기**

이름 짓기 또한 타입 설계에서 가장 중요한 부분이다.

엄선된 타입, 속성, 변수의 이름은 의도를 명확히 하고 코드와 타입의 추상화 수준을 높여준다.

코드로 표현하고자 하는 모든 분야에는 주제를 설명하기 위한 전문 영어들이 있다.

자체적으로 용어를 만들어 내려고 하지말고, 해당 분야에 이미 존재하는 용어를 사용해야 한다. 

전문분야 용어는 정확하게 사용해야 하낟. 특정용어를 다른 의미로 잘못 쓰게 되면, 직접 만들어 낸 용어보다 더 혼란을 주게 된다.

속성 변수에 이름을 붙일 때 명심해야 할 세가지 규칙이 있다.

- 동일한 의미로 나타낼 때는 같은 용어를 사용해야 한다.
- 모호하고 의미 없는 이름은 피해야 한다.
- 이름을 지을 때는 포함된 내용이나 계산 방식이 아니라 데이터 자체가 무엇인지 고려해야한다.

- 가독성을 높이고, 추상화 수준을 올리기 위해서 해당 분야의 용어를 사용해야 한다.
- 같은 의미에 다른 이름을 붙이면 안된다. 특별한 의미가 있을 때만 용어를 구분해야 한다.

## 아이템 37

**공식 명칭에는 상표를 붙이기**

if를 사용해서 오류를 잡아준다. 

path 값이 절대 경로와 상태 경로 둘다 될수 있다면, 타입을 정제해 주면 타입 가드를 사용해서 오류를 방지할 수 있습니다.

- 타입스크립트는 구조적 타이핑을 사용하기 때문에, 값을 세밀하게 구분하지 못하는 경우가 있다.
- 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야 한다.
- 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있다.
