# 아이템 4 구조적 타이핑에 익숙해지기

### 자바스크립트는 본직적으로 덕 타이핑(duck typing) 기반이다

<aside>
💻 덕 타이핑이란?

객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우, 객체를 해당 타입에 속하는 것으로 간주하는 방식
”만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 그 새는 오리다”

</aside>

만약 어떤 함수의 매개변수 값이 모두 주어진다면, 그 값이 어떻게 만들어졌는지 신경 쓰지 않고 사용한다.

**타입스크립트 또한 이런 동작, 즉 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경쓰지 않는 동작을 그대로 모델링한다.**
구조적 타이핑을 이해한다면 오류인 경우와 오류가 아닌 경우의 차이를 알 수 있고, 더욱 견고한 코드를 작성할 수 있다.

```tsx
interface Vector2D {
	x: number
	y: number
}
interface NamedVector {
	name: string
	x: number
	y: number
}

function calculateLength(v: Vector2D) {
	return Math.sqrt(v.x * v.x + v.y * v.y)
}
```

여기서 calculateLength 함수는 매개변수로 Vector2D 타입의 매개변수를 받지만, 매개변수로 NamedVector 타입의 인자를 넣어줘도 함수가 정상 작동한다는 점이다.

```tsx
const value: NamedVector = { x: 3, y: 4, name: 'KMin' }
calculateLength(value) // 정상, 결과는 5
```

NamedVector 의 구조가 Vector2D 와 호환이 되기 때문에 calculateLength 호출이 가능한것!

⇒ 여기서 **‘구조적 타이핑(structural typing)’**이라는 용어가 사용된다!

## 구조적 타이핑

구조적 타이핑 때문에 문제가 발생하기도 한다.

```tsx
interface Vector3D {
	x: number
	y: number
	z: number
}

function mormalize(v: Vector3D) {
	const length = calcualteLength(v)
	return {
		x: v.x / length
		y: v.y / length
		z: v.z / length
	}
}
```

그러나 이 함수는 1보다 조금 더 긴(1.41) 길이를 가진 결과를 출력한다.

타입스크립트가 오류를 잡지 못한 이유는 무엇일까?

calculateLength 는 2D 를 기반으로 연산하는데, 버그로 인해 normalize 가 3D 벡터로 연산되었다. z 가 정규화에서 무시된 것이다.
Vector3D 와 호환되는 {x, y, z} 객체로 calculateLength 를 호출하면, 구조적 타이핑 관점에서 x 와 y 가 있어서 Vector2D 와 호환된다.
따라서 오류가 발생하지 않았고, 타입 체커가 문제로 인식하지 못한다.

함수를 작성할 때 호출에 사용되는 매개변수의 속성들이 매개변수의 타입에 선언된 속성만을 가질 거라 생각하기 쉽다.
이러한 타입은 봉인된(sealed) 또는 정확한(precise) 타입이라고 불리며, 타입스크립트 타입에서는 표현할 수 없다.
타입스크립트의 타입은 열려(open)있다

즉, 실제 요구되는 인터페이스와 다르더라도 요구하는 속성을 가지고 있다면 해당 인터페이스도 받을 수 있다.