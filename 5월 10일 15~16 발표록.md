# 꽁치

1. 일반적인 상황에서 인덱스 시그니처는 키의 이름이 무엇인지 알 수 없을 때 유용하게 사용할 수 있다.
2. 하지만 범위가 너무 광범위해지기 때문에 무조건적으로 쓰기보단 그 때 그 때 상황에 맞춰서 유용하게 쓰거나, Record 제너릭 타입 또는 매핑된 타입(아이템14)을 사용한다.
3. 인덱스 시그니처에 number 를 쓰는 것은 순수한 타입스크립트 코드이나, 이거보단 Array, 튜플, ArrayLike 를 사용하는 것이 좋다(라고는 하는데 아직은 잘 이해가 안 간다)

# 삼앵

### 아이템 15
  - 타입스크립트는 타입에 인덱스 시그니처를 명시하여 유연하게 매핑을 표현할수있다.
    Ex) {[Key:T]:U}
  - 런타임때까지 객체의 속성을 알수없을경우에만 인덱스 시그니처를 사용하자.
  - 인덱스 시그니처보다 가능하다면 명확한타입을 사용하자.

  ### 아이템 16
  - 암시적 타입강제 관련된 문제는 대부분 === !== 로 해결이가능하다.
  - 배열은 객체이다.
  - 인덱스 시그니처가 number로 표현되어있다면 입력한 값또한 number이고 실제 런타임시 사용키는 string이다.
  - String타입의 키로 객체에 접근하려면 index signature를 선언해야 한다
  - 어떤 길이를 가지는 배열과 비슷한형태의 튜플을 사용하고싶다면 타입스크립트에있는 arrayLikeType을 사용하자.

# 호로록

1. 인덱스 시그니처,,,?
- 속성 목록 + 개수가 확실히 정해지지 않았을 때 사용하는 것 같다.

```tsx
//인덱스 시그니처가 없을 때

interface test1 {
    name : string;
    age : number;
}

const data1 : test1 =  {
    name : '홍길동',
    age : 26,
    address: '서울' // 없는 속성이라 오류
}


//인덱스 시그니처를 추가하면?

interface test2 {
    name : string;
    age : string;
    [property : string] : string;
}

const data2 : test2 =  {
    name : '홍길동',
    age : '26',
    address: '서울'
} // 오류 안 남
```

근데,,,이렇게 하면 다 string만 되는 거 아닌가,,,?

⇒ 유니온 타입을 쓰면 된다!!!! 이게 이럴 때 쓰는 거였군:D

- 대신 인덱스 시그니처는 범위가 너무 넓다.

2. number을 인덱스 시그니처로 사용할 일은 많지 않다. 있다고 해도 배열로 사용하는 것이 더 좋다. ⇒ 아직 이 이상으로 이해를 못했음;

# 보보도도

## 아이템 15

동적 데이터에 인덱스 시그니처 사용하기

자바스크립트의 장점 중 하나는 바로 객체를 생성하는 문법이 간단하다.

type Rocket = {[property: string]:string};
const rocket: Rocket = {
    name : "Falcon 9",
    variant : "v1.0",
    thrust: "4,940 kN",
};


[property: string]: string 이 인덱스 시그니처이며 다음 세가지를 의미한다.

- 키의 이름 : 키의 위치만 표시하는 용도이며, 타입 체커에서는 사용하지 않는다.
- 키의 타입 : string이나, number 또는 symbol의 조합이어야 하지만 보통은 string을 사용한다.
- 값의 타입 : 어떤 것이든 될 수 있다.

이 후 4가지 단점이 드러나게 된다.

1. 잘못된 키를 포함해 모든 키를 허용한다.
2. 특정 키가 필요하지 않는다.
3. 키마다 다른 타입을 가질 수 없다.
4. 타입스크립트 언어 서비스는 키가 무엇이든 가능하기에 저동완성 기능이 동작 안한다.

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용한다.
- 안전한 접근을 위해 인덱스 시그니처 값 타입에 undefined를 추가하는 것을 고려해야 한다.
- 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

## 아이템 16

number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

숫자는 키로 사용할 수 없다. 숫자로 사용하려고 하면 자바스크립트 런타임은 문자열로 반환한다.

배열의 요소에 접근할때는 숫자로 인덱스를 사용하는것은 당연하나. 인덱스들은 문자열로 변환되어 사용된다.

- 인덱스에 신경 쓰지 않는다면 for-of를 사용하는게 좋다.
- 인덱스의 타입이 중요하다면 Array.prototype.forEach를 사용한다.
- 루프 중간에 멈춰야 한다면 for루프를 사용하는것이 좋다.
- 타입이 불확실하다면, for-in 루프는 for-of 또는 for 루프에 비해 몇 배나 느리다.

어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 ArrayLike 타입을 사용한다.

function checkedAccess<T>(xs: ArrayLike<T>, i : number): T {
    if(i < xs.length) {
        return xs[i];
    }
    throw new Error(`배열의 끝을 지나서 ${i}를 접근하려고 했습니다.`)
}


- 배열은 객체이므로 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.
- 인덱스 시그니처에 number 를 사용하기 보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.

# 너두

## 아이템16 number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기

- 타입스크립트는 숫자 키를 허용한다
- iterator 객체에 대해 number타입을 관용적으로 허용한다
- 타입이 불확실하면 for-in을 쓰는것은 안좋다
- 배열과 비슷한 형태의 튜플을 사용하고 싶다면 ArrayLike를 사용한다

모르겠는것

- Array 타입이 사용하지않을 push나 concat과 같은 속성을 가지는게 납득할만하면 안되는건가

# 애한

## 요약
자바스크립트 객체는 문자열 키를 타입의 값에 관계없이 매핑.

인덱스 시그니처 : 동적데이터를 표현할 때 사용. 헤더 행에 열이름이 있고 데이터 행을 열 이름과 값으로 매핑하는 객체로 나타내고 싶은 경우 사용

타입체크 수행시 단점 4가지
잘못된 키를 포함해 모든 키 허용
특정키 필요 x
키마다 다른 타입 가질 수 x
자동완성기능 동작 x

암시적 타입 강제는 === 과 !== 를 통해 해결 가능

키는 보통 숫자가아닌 문자열이다. 인덱스 시그니처러 숫자타입을 사용할수도 있지만 이는 버그를 잡기 위한 순수 타입스크립트 코드이다.
인덱스 시그니처에 숫자를 사용하기보다 array나 튜플, 또는 arraylike 타입을 사용하는게 좋다.