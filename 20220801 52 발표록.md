# 뽀또

## 아이템 52

**태스팅 타입의 함정에 주의하기**

타입 선언도 테스트를 거쳐야 한다. 그러나 타입 선언을 테스트하기는 매우 어렵다.

타입 선언에 대한 테스트 코드를 작성할 때 타입스크립트가 제공하는 도구를 사용하여 단언문으로 때우기 십상이지만 이런 방법에는 몇가지 문제가 있다.

궁극적으로 dtslint 또는 타입 시스템 외부에서 타입을 검사하는 유사한 도구를 사용한것이 더 안전하고 간단하다.

로대시와 언더스코어를 통해 타입을 검사할 수 있다.

- 타입을 테스트 할 때는 특히 함수 타입을 동일성과 할당 가능성의 차이점을 알고 있어야 한다.
- 콜백이 있는 함수를 테스트할 때, 콜백 매개변수의 추론된 타입을 체크해야 합니다.
- 또한 this가 API의 일부분이라면 역시 테스트 해야한다.
- 타입 관련된 테스트에서 any를 주의해야 한다. 더 염격한 테스트를 위해 dslint같은 도구를 사용하는 것이 좋다.

**의존성 분리를 위해 미러 타입 사용하기**

`@types/node` 에 의존하기 때문에 `@types/node` 는 devDependencies로 포함되어야 한다.

각자가 필요한 모듈만 사용할 수 있도록 구조적 타이핑을 적용할 수 있습니다.

`@types/node` 있는 Buffer 선언을 사용하지 않고, 필요한 메서드와 속성만 별도로 작성할 수 있다.

- 필수 아닌 의존성을 분리할 때는 구조적 타이핑을 사용하면 됩니다.
- 공개한 라이브러리를 사용하는 자바스크립트 사용자가 `@types` 의존성을 가지지 않게 해야 한다.
- 웹 개발자가 NodeJS 관련된 의존성을 가지지 않게 해야한다.

# 너두

## 아이템 52 테스팅 타입의 함정에 주의하기

- 프로젝트를 공개하려면 테스트 코드 작성은 필수이며 타입 선언 테스트도 거쳐야 한다. 그러나 타입 선언은 테스트하기 어려움. 그래서 단언으로 떄우기 쉽지만 문제가있어서 결국 dtslint나 타입시스템 외부에서 타입검사를 하는 도구를 쓰는게 좋음
- 또 로대시 찬양함
- 실행에서 체크하고 반환값은 체크를 하지 않음 결국 테스트는 통과함
- 테스팅을 위해 할당을 사용하는 방법은 근본적 문제가 2가지 있음

1. 불필요한 변수를 만들어야함. 샘플코드를 넣으면 린트를 꺼야하는 경우도 발생
   일반적인 해결책은 변수도입 대신 헬퍼함수를 정의하는 것임

   function assertType<T>(x:T){}
   assertType<number[]>(map(['john','paul'],name=>name.length));

   불필요한 변수 문제를 해결하지만 문제점이 남아있다

   1. 두타입이 동일한지 체크하는게 아니라 할당 가능성을 체크하는 것임. 심벌로 보면 const n = 12는 숫자 리터럴인데 number의 서브타입이고 할당 가능성 체크를 통과함
      근데 객체의 타입을 체크하는 경우 문제가 발견됨
      2개 타입을 넣었을떄 하나는 나오지만 하나는 안나오는 경우가 생김
      double함수의 체크가 성공한이유는 타입스크립트의 함수는 매개변수가 더 적은 함수타입에 할당 가능하기 떄문임

- assertType을 제대로 사용하는 방법은 Parameters와 ReturnType 제너릭 타입을 이용해 함수의 맥배녀수 타입과 반환만 분리하여 테스트 할수 있음

  const double = (x:number) => 2\*x;
  let p: Parameters<typeof double> = null!;
  assertType<[number, number.>(p

  너무자세한건 패스

- dtslin를 사용하면 // $ExpectType string 이와같이 쓸수있음. 이 비교과정은 편집기에서 타입 선언을 눈으로 보고 확인하는 것과 같은데 dtslin는 이런 과정을 자동화함 하지만 단점은 앞뒤가 다르면 다른타입으로 인식함
