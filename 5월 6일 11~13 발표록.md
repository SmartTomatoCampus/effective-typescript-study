# 너두

아이템 11 잉여 속성 체크의 한계 인지하기

- 잉여속성체크란게 있으며 할당가는 검사와 별도과정이다
- 잉여속성체크는 대소문자를 구분한다

모르겠는점

- 잉여속성체크 될때있고 안될때있고 타입추론과 뭐가다르며 솔직히 선호하지않아 항상 인덱스 시그니처를 썻음

아이템 12 함수 표현식에 타입 적용하기

- 타스에선 함수표현식을 쓰는게 좋다, 재사용이 가능
- 라이브러리를 만든다면 공통 콜백 함수를 위한 타입선언을 제공하는게 좋다
- typeof로 추론하게 해준다고 한다(어제 안된다고 하지않았었나?)

아이템 13 타입과 인터페이스의 차이점 알기

- 인터페이스는 확장은 가능한데 유니온 타입같은 조건을 주지 못한다 혹은 확장하려면 타입과 &를 써야한다
- 클래스는 타입과 인터페이스를 둘다  사용할 수 있다

type NamedVariable = (Input | Output) & {name:string};


- 위와같이 사용이 가능하며 쓰임새가 많다
- 인터페이스는 보강이 가능하다 이를 선언 병합이라고 함(진짜 괴랄한 언어입니다)

# 뽀또

## 아이템 11

잉여 속성 체크의 한계 인지하기

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립는 해당 타입의 속서이 있는지 그리고 그외의 속성이 없는지 확인한다.

잉여속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워지기에, 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입 시스템에 대한 개념을 잡을 수 있다.

document 나 new HTMLAnchorElement는 객체 리터럴이 아니기 때문에 잉여 속성 체크가 되지 않는다.

잉여 속성 체크는 타입 단언문을 사용할 때에도 적용되지 않습니다.

const foo = {x : true , y : "Jang" } as Name ; // 정상


잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

구조적 관점에서 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.

공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않습니다.

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름이 오타 같은 실수를 잡는데 효과적인 방법이다.

잉여 속성 체크에는 한계가 있어, 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템 12

함수 표현식에 타입 적용하기

자스와 타스에서는 함수 문장과 함수 표현식을 다르게 인식한다.

타입스크립트에서는 함수 표현식을 사용하는 것이 좋으며, 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.

type DiceRollFn = (sides :number ) => number;
const rollDice : DiceRollFn = sides => { ... };


함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다.
- 다른 함수의 시그니처를 참조하려면 typeof 함수 를 사용하면 된다.

## 아이템 13

타입과 인터페이스의 차이점 알기

명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임의 개념이다.

명명된 타입을 정의해 일관성을 유지해야 한다.

- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 타입은 인터페이스를 확장할 수 있다.
- 인터페이스는 타입을 확장할 수 있지만 유니온은 할 수 없다.
- 인터페이스로도 튜플과 비슷하게 구현할 수 있기는 하다.