# Effective - #3장 타입 추론

![327754-eng](https://user-images.githubusercontent.com/34502254/168100406-8929de59-6ccb-4f91-981f-f520586eaf70.png)

## 아이템 19

**추론 가능한 타입을 사용해 장황한 코드 방지하기**

```tsx
let x :number = 12; 
```

이렇게만 하여도 타입스크립트를 잘 사용하고 있는 것이다.

타입 추론이 된다면 명시적 타입 구문은 필요하지 않는다. 오히려 방해가 될 뿐이다.

만약 타입을 확신하지 못한다면 편집기를 통해 체크하면 된다.

타입이 추론되면 리팩토링 역시 용이해진다.

```tsx
interface Product {
	id : number;
	name : string;
	price : number;
}

function logProduct(product : Product) {
	const id: number = product.id;
	const name : string = product.name;
	const price : number = product.price;
	console.log(id, name, price);
}
```

만약 id에 number 가 아닌 string이 들어간다고 가정하면, 오류가 뜨게 되고, 명시적이 아니라면 괜찮게 넘어갔을 것이다.

이를 방지하기 ? 위해서 비구조화 할당문을 사용해 구현하는게 좋다.

```tsx
function logProduct(product: Product) {
	const { id, name, price } = product;
	console.log(id, name, price);
}
```

```tsx
const cache: {[ticker:string] : string} = {};
function getQuote(ticker : string): Promise<number> {
	if( ticker in cache ) {
		return cache[ticker];
	}
}
```

반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.

오류의 위치를 제대로 표시해 주는 이점 외에도 반환타입을 명시해야 하는 이유가 두가지 있다.

1. 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있기 때문이다.
    1. 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야 하낟.
    2. 미리 타입을 명시하는 방법은, 함수를 구현하기 전에 테스트를 먼저 작성하는 테스트 주도 개발과 비슷하다.
2. 명명된 타입을 사용하기 위해서 이다.
    1. 반환 타입을 명시하면 더욱 직관적인 표현이 된다.
    2. 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점은 커진다.

- 타입스크립트가 타입을 추론할 수 있다면 타입구문을 작성하지 말아라
- 함수 메서드의 시그니처에는 타입 구문이 있지만 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.

## 아이템 20

**다른 타입에는 다른 변수 사용하기**

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 된다.

다른 타입에는 별도의 변수를 사용하는게 바람직한 이유

- 관련이 없는 변수라면 타입은 분리해서 값을 적용시켜야 한다.
- 타입 추론을 향상시키며 타입 구문이 불필요하다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입이 좀 더 간결해진다.
- const 로 변수를 지정하면 간결해지고 타입 체커가 추론하기에도 좋다.

변수의 값은 바뀔 수 있지만, 타입은 일반적으로 바뀌지 아니한다.

혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.

## 아이템 21 타입 넓히기

런타임에 모든 변수는 유일한 값을 가진다. 그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 타입을 가진다.

상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다. 즉, 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.

타입스크립트에서는 이러한 과정을 넓히기라고 부르고, 넓히기 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있다.

타입스크립트는 넓히기 과정을 제어할 수 있도록 몇가지 제공한다.

1. const를 사용해서 더 좁은 타입이 된다.
    1. 타입의 오류를 해결할 수도 있다.

```tsx
const x = "x";
let vec = { x : 10, y : 20, z : 30 };
getComponent(vec, x);
```

1. 추가적인 문맥을 제공하는 것이다. 함수의 매개변수로 값을 전달하는 방법.
2. const 단언문을 사용하는 것이다.
    1. const 단언문과 변수 선언에 쓰이는 let이나 const와 혼동해서는 안된다.
    2. const 단언문은 온전히 타입 공간의 기법이다.

```tsx
const v1 = {
	x : 1,
	y : 2,
};

const v2 = {
	x : 1 as const,
	y : 2,
};

const v3 = {
	x : 1,
	y : 2,
} as const;
```

const 을 붙이게 되면, 타입스크립트는 최대한 좁은 타입으로 추론한다.

- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 const 타입 구문, 문맥 as const에 익숙해져야 한다.

## 아이템 22

**타입 좁히기**

일반적인 예시로는 null 체크이다.

```tsx
const el = document.getElementById('foo');
// HTMLElement | null
if(el) {
	el
	el.innerHTML = "Party Time".blink();
// HTMLElement
} else {
	el
	alert("No element #foo");
}
// null
```

null 이라면 블록은 실행되지 않는다. null 타입을 미리 알고 있기에 더 좁은 타입이 되어 작업이 훨씬 쉬워진다.

이러한 방법은 분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.

```tsx
const el = document.getElementById("foo");
//HTMLElement | null
if(!el) throw new Error("Unable to find #foo");
el;
// HTMLElement
el.innerHTML = "Party Time".blink();
```

미리 null (!) 로 표기후 에러를 반환하였기에 더욱 더 좁히게 되었다.

그외 타입을 좁힐수 있는 방법으로

- instanceof 타입체커를 통해 타입을 좁힐수도 있다.
- 속성 체크로도 타입을 좁힐 수도 있다.
- Array.isArray 같은 일부 내장함수로도 타입을 좁힐 수도 있다.
- 조건문에서 타입을 좁히는데 매우 능숙하다.
- 명시적 태그를 붙이는 방법도 타입을 좁히는 방법이다.

만약 타입스크립트가 타입을 식별하지 못한다면 식별을 돕기 위해 커스텀 함수를 도입할 수 잇다.

```tsx
function isInputElement(el: HTMLelement) : el is HTMLInputElemet {
	return "value" in el;
}

function getElementContent(el: HTMLElement) {
	if(isInputElement(el)) {
		el; // HTMLInputElement
		return el.value
	}
	el; // HTMLElement
	return el.textContent;
}
```

이러한 기법을 사용자 정의 타입 가드라고 한다.

el is HTMLInputElement 는 함수의 반환이 true인 경우 타입 체커에게 매개변수의 타입을 좁힐 수 있다고 알려준다.

어떤 함수들은 타입 가드를 사용하여 배열과 객체의 타입 좁히기를 할수 있다.

- 편집기에서 타입을 조사하는 습관을 지니면 타입 좁히기가 어떻게 동작하는지 자연스레 익힐 수 있다.
- 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 한다.
- 태그된 구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있다.

## 아이템 23

**한꺼번에 객체 생성하기**

타입스크립트 타입은 일반적으로 변경되지 않아, 자바스크립트 패턴을 타입스크립트로 모델링하는게 쉽다.

즉 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.

```tsx
interface Point ( x: number , y:number };

const pt = {
	x : 3,
	y : 4,
};

as 를 사용하여 타입체커를 통과하게 만들수도 있다.

const pt = {} as Point;
pt.x = 3;
pt.y = 4;

// 위와 아래는 같다.

const pt: Point = {
	x : 3, 
	y : 4,
}
```

객체 전개 연산자를 통해 큰 객체를 한꺼번에 만들어 낼수도 있다.

```tsx
const namedPoint = {...pt, ...id}
namedPoint.name // type string 
```

타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 null 또는 {} 으로 객체 전개를 사용하면 된다.

```tsx
declare let hasMiddle : boolean;
const firstLast = {first : "Harry" , last : "Truman" };
const president = {
	...firstLast,
	...(hasMiddle 
	? {middle: "S" } 
	: {})
};
```

전개 연산자로 한꺼번에 여러 속성을 추가할수도 있다는 것이다. 

유니온보다 선택적 필드를 다루기에 더 쉽기 때문에 선택적 필드 방식으로 표현하려면 헬퍼 함수를 사용하면 된다.

```tsx
function addOptional<T extends object, U extends object>(
	a: T, b: U | null
) : T & Partial<U> {
	return {...a, ...b};
}
const pharaoh = addOptional(
	nameTitle,
	hasDates ? { start: -2578 , end : -2524 } : null
);
pharaoh.start // 정상 타입이 number | undefined
```

- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 한다.
- 안전한 타입으로 속성을 추가하려면 객체 전개를 사용하면 된다.
- 객체에 조건부로 속성을 추가하는 방법을 익히자.

## 아이템 24

**일관성 있는 별칭 사용하기**

하나의 객체의 변수를 만들어 할당하여 그 타입을 변경하면 원래 속성값에서도 변경하게 된다.

별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵기에 별칭을 신중하게 사용해야 한다.

타입을 자료구조형으로 사용하여 속성을 빠르게 체크할수 있다.

```tsx
interface Coordinate {
	x : number;
	y : number;
}

interface BoundingBox {
	x : [number , number];
	y : [number , number];
}

interface Polygon {
	exterior : Coordinate[];
	holes : Coordinate[][];
	bbox? : BoundingBox;
}
```

객체 비구조화를 이용할 때는 두가지를 주의해야한다.

- 전체 속성이 아니라 각 속해 있는 선택적 속성일 경우에 속성 체크가 더 필요하기에 타입 경계에 null 값을 추가하는 것이 좋다.
- 선택적 속성이 적합하다고 생각하지만, 안에 속해 있는 별칭이 선택적이라면 값이 겂거나 빈 배열이 될 것이다.

- 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
- 함수 호출이 객체 속성의 타입 정제를 무효화 할 수 있다는 점을 주의해야 한다.
- 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.

## 아이템 25

**비동기 코드에는 콜백 대신 async 함수 사용하기**

자바스크립트에서는 콜백 지옥을 필연적으로 마주칠수 밖에 없는데, 이를 해결하기 위한 비동기로 프로미스를 사용하면 된다.

Promise.all 같은 고급 기법을 사용해서 처리할수 있지만, async await를 키워드를 도입해서 콜백 지옥을 더욱 간단하게 처리할 수 있다.

async await 중인 프로미스가 거절 되면 예외를 던지기에 이를 통해 일반적인 try/catch 구문을 사용할 수 있다.

콜백 보다는 프로미스나 async/await 를 사용해야하는 이유.

1. 콜백보다는 프로미스가 코드를 작성하기 쉽다.
2. 콜백 보다는 프로미스가 타입을 추론하기 쉽다.

병렬로 페이지를 로드하고 싶다면 Promise.all을 사용해서 프로미스를 조합하면 된다.

```tsx
async function fetchPages() {
	const [res1,res2,res3] = await Promise.all([
		fetch(url1), fetch(url2), fetch(url3)
	]);
}
```

입력된 프로미스들 중 첫 번째가 처리될 때 완료되는 Promise.race도 타입 추론과 잘 맞는다. 프로미스에 타임아웃을 추가하는 방법이다.

```tsx
function timeout(millis:number) : Promise<never> {
	return new Promise((resolve, reject) => {
		setTimeout(() => reject('timeout'),millis);
	});
}

async function fetchWithTimeout(url: string, ms: number) {
	return Promise.race([fetch(url), timeout(ms)]);
}
```

Promise.race의 반환 타입은 입력 타입들의 유니온이고 위는 , 

`Promise<Response | never>` 가 된다.

프로미스를 사용하면 타입스크립트의 모든 타입 추론이 재대로 작동하기에 콜백을 우수히 처리하는것보다 프로미스를 사용하는것이 매우 중요하다.

async await을 사용하는 이유로는.

1. 일반적으로 더 간결하고 직관적인 코드가 된다.
2. async 함수는 항상 프로미스를 반환하도록 강제된다.

```tsx
const getNumber = async () => 42;
// () => Promise<number>
```

async 함수에서 프로미스를 반환하면 또 다른 프로미스로 래핑되지 않기에 프로미스는 

`Promise<Promise<T>>` 가 아닌 `Promise<T>` 가 된다.

## 아이템 26

**타입 추론에 문맥이 어떻게 사용되는지 이해하기**

타입스크립트는 타입을 추론할 때 단순히 값만 고려하지는 않는다.

값이 존재하는 문맥까지도 살피게 되는데 문맥을 고려해 타입을 추론하면 가끔 이상하기에, 타입 추론이 어떻게 사용되는지 이해도가 필요하다.

```tsx
let language : Language = "JavaScript";
setLanguage(language)
```

```tsx
const language = "JavaScript";
setLanguage(language)
```

상수나, 타입선언을 통하여 해당 타입에 문자열 리터럴을 제공함으로써, 타입체커에게 정확한 타입을 제공할수 있게 해준다.

그러나 이것을 재할당을 하기 위해서는 타입 선언이 필요하다. 이 타입선언을 하기 위해서는 문맥을 분리해야 하는데, 문맥을 분리하게 되면 추후 근본적인 문제를 발생시킬 수 있다.

튜플 타입에서도 문맥과 값을 분리할 경우 타입 문제가 생기게 된다. 이를 해결할 수 있는 방법은. any가 있지만, const를 사용하여 선언하게 된다면 오류를 고칠 수 있으며, as const 를 통해 깊은 복사 개념을 활용한 상수라는 개념을 타입스크립트에 알려주면 된다.

```tsx
const loc = [ 10, 20 ] as const;
panTo(loc);
// ~~~ readonly [10, 20] 형식은 readonly 이며
// 변경 가능한 형식 [ number ,number ] 에 할당할 수 없다.
```

이 방식은 타입을 readonly 로 추론되기에, 다른 방법을 적용해야 한다.

```tsx
function panTo(where : readonly [number, number]) {... }
const loc = [10 , 20] as const;
panTo(loc) // 정상
```

타입 시그니처를 수정할 수 없는 경우라면 타입 구문을 사용해야 한다.

as const는 문맥 손실과 관련한 문제를 깔끔하게 해결할 수 있지만, 한가지 단점을 가지고 있다. 만약 타입 정의에 실수가 있다면, 오류는 타입 정의가 아니라 호출되는 곳에서 발생하는 것이다.

> **이러한 오류는 근본적인 원인을 파악하기 힘들다.**
> 

- 객체 사용 시에도 문맥에서 값과 분리하는 과정에서 문제가 발생될 수 있다.
- 콜백시에도 다른 함수로 전달할때, 타입스크립트는 콜백의 매개변수 타입을 추론하기 위해 문맥을 사용한다.
- 타입 추론에서 문맥이 어떻게 사용되는지 확인해야한다.
- 변수가 정말로 상수라면 상수 단언(as const)를 사용해야 한다.
    - 상수 단언은 사용한 곳에서 오류가 발생되기에 사용한 곳에서 오류 체크를 해야한다.


## 아이템 27

**함수형 기법과 라이브러리로 타입 흐름 유지하기**

로대쉬를 사용함으로써 더욱 복잡한것들을 절약한 코드로 매우 짧게 코드를 작성할 수 있다.

같은 코드이더라도, 타입스크립트로 작서앟면 서드파티 라이브러리를 사용하는 것이 무조건 유리하다.

로대시를 이용하여 코드를 작성했다면 별도의 수정 없이도 타입 체커가 통과가 되고, 타입의 별칭이 이루어져 타입이 정확하다는것을 판단해줄 수도 있다.

로대시의 어떤 기발한 단축 기법이라도 타입스크립트로 정확하게 모델링이 될 수 있다.

타입 흐름을 개선하고, 가독성을 높이고 명시적인 타입 구문의 필요성을 줄이기 위해 직접 구현하기보다는 내장된 함수형 기법과 로대시 같은 유틸리티 라이브러리를 사용하는 것이 좋다.
