# Effective - #5장 any 다루기

![327754-eng](https://user-images.githubusercontent.com/34502254/168100406-8929de59-6ccb-4f91-981f-f520586eaf70.png)

## 아이템 38

any 타입은 가능한 한 좁은 범위에서만 사용하기

```tsx
const x : any 이렇게 쓰지말고, x as any 이렇게 사용해라 
```

전체에 as any 보다는 최소한의 속성 하나에면 as any를 적용시켜 주는것이 좋다.

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.
- 함수의 반환 타입이 any인 경우 타입 안전성이 나빠진다.
- any 타입을 반환하면 절대 안된다.
- 강제로 타입 오류를 제거하려면 any 대신 `@ts-ginore` 을 사용하는 것이 좋다.


## 아이템 39

**any를 구체적으로 변형해서 사용하기**

any는 모든 값을 아우르는 매우 큰 범위의 타입이다. 

자바스크립트의 기본 오퍼레이터는 타입을 가지고 있기에 타입을 적어주지 않아도 된다.

배열형태가 any[][]인 경우라면, for in 으로 key 값을 넣어주어야 한다.

any보다 더 정확하게 모델링할 수 있도록 any[] 또는`{[id : string ] : any }` 또는 `() ⇒ any` 처럼 구체적인 형태를 사용해야 한다.


## 아이템 40

**함수 안으로 타입 단언문 감추기**

- 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상황까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없다.
- 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는게 좋다.
- 타입 선언문은 일반적으로 타입을 위험하게 만드지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다.
- 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 해야한다.

## 아이템 41

**any의 진화를 이해하기**

예를 들어 number라고 정의했지만, 함수에 의해서 number[]라고 타입이 추론이 될수 있다.

이러한 타입은 진화라고 말한다.

타입의 진화는 타입 좁히기와는 다르다. 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.

- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있습니다.
- 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 한다.
- any를 진화시키는 방식보다 명시적 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.


## 아이템 42

**모르는 타입의 값에는 any 대신 unknwon을 사용하기**

unknwon 에는 함수의 반환값과 관련된 형태 , 변수 선언과 관련된 형태, 단언문과 관련된 형태가 있는데, 이를 순차적으로 알아볼 수 있다.

함수의 반환타입을 any를 사용하는 것은 좋지 않은 설계이다. unknwon 타입을 반환하는 것이 더 안전하다.

any가 강력하면서도 위험한 이유 2가지

1. 어떠한 타입이든 any 타입에 할당 가능하다.
2. any 타입은 어떠한 타입으로도 할당 가능하다.

unknwon 타입의 범위를 좁히기 위해서는 상당히 많은 노력이 필요하다.

unknwon 대신 제너릭 매개변수가 사용되는 경우가 있다.

unknwon 대신 object 또는 {} 을 사용하는 코드들이 존재한다. object 또는 {} 를 사용하는 방법 역시 unknwon 만큼 범위가 넓은 타입이지만 , unknwon 보다는 범위가 약간 좁다.

- {} 타입은 null 과 undefined 를 제외한 모든 값을 포함합니다.
- object 타입은 모든 비기본형 타입으로 이루어집니다. 여기에는 true 또는 12 또는 ‘foo’ 가 포함되지 않지만 객첻와 배열은 포함됩니다.

- unkwon 은 any 대신 사용할 수 있는 안전한 타입이다.
- 어떠한 값이 있지만 그 타입을 알지 못하는 경우라면 unknwon을 사용하면 된다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknwon을 사용하면 된다.
- {} , object , unknwon의 차이점을 이해해야 한다.


## 아이템 43

**몽키 패치보다는 안전한 타입을 사용하기**

window, document에 변수명을 넣어 타입을 전역으로 사용하는 방법도 있다.

interface의 특수 기능 중 하나인 보강을 사용하는 것이다.

- 타입이 더 안전하다. 타입 체커는 오타나 잘못된 타입의 할당을 오류로 표시한다.
- 속성에 주석을 붙일 수 있다.
- 속성에 자동완성을 사용할 수 있습니다.
- 몽키 패치가 어떤 부분에 적용되었는 정확한 기록이 남는다.

보강을 사용할 때 주의해야 할 점은 모듈 영역과 관련이 있다.

- 전역 변수나 DOM에 데이터를 저장하지 말고 데이터를 분리하여 사용해야 한다.
- 내장 타입에 데이터를 저장해야 하는 경우 안전한 타입 접근법 중 하나로 보강이나 사용자 정의 인터페이스로 단언을 해야 하낟.
- 보강의 모듈 영역 문제를 이해해야 한다.

## 아이템 44

**타입 커버리지를 추적하여 타입 안정성 유지하기**

명시적 any 타입으로 범위를 좁히고 구체적으로 만들어도 여전히 any이다. any는 코드 전반에 영향을 미친다.

서드파티 타입 선언 같은 경우는 `@types` 선언 파일로부터 any 타입이 전파되기 때문에 특별히 조심해야 한다.
