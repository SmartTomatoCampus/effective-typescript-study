# Effective - #2장 타입스크립트의 타입 시스템

![327754-eng](https://user-images.githubusercontent.com/34502254/166692339-dad60070-d050-4f7e-8429-a3c197a2d55a.png)

# 2장 타입스크립트의 타입 시스템

## 아이템 6

**편집기를 사용하여 타입 시스템 탐색하기**

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용할때에는 에디터에서 코드자동완성, 명세, 검사, 검색, 리팩토링이 가능하다.

마우스를 호버 하고 해당하는 타입이 무엇인지 확인이 가능하다.

![스크린샷_2022-05-04_오후_10 09 44](https://user-images.githubusercontent.com/34502254/166692374-1657a848-87a2-4289-a087-a0d486c0f099.png)

타입이 기대한것과 다르다면 명시적으로 선언이 가능하고, 실제 문제가 발생하는 곳을 찾아볼 수 있다.

객체의 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지도 살펴보는것이 좋다.

라이브러리 혹은 api의 타입이 궁금하다면 해당 노드모듈로 이동해서 타입을 확인하는 방법도 있다.

## 아이템 7

**타입이 값들의 집합이라고 생각하기**

코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있고, 할당 가능한 값들의 집합이 타입이라고 생각하면 된다.

해당한 이 집합은 타입의 범위라고 부르기도 한다.

타입스크립트에서 유닛 타입이라고 불리우는 리터럴 타입

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온타입을 사용한다.

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

`|`  으로 또는 이라는 타입을 선언할 수 있다.

![스크린샷_2022-05-04_오후_10 20 14](https://user-images.githubusercontent.com/34502254/166692396-796d4f9f-08ca-4a7d-9679-9987fb4ef0d9.png)

인터페이스는 구조적 타이핑 규칙에 의해 어떠한 값이 다른 속성도 가질 수 있음을 의미한다. 

집합의 느낌을 살려, extends키워드를 사용하여 ~에 할당 가능하도록 한다 라는 의미로서 집합이라는 의미로 받아들일 수 있다.

![스크린샷_2022-05-04_오후_10 22 56](https://user-images.githubusercontent.com/34502254/166692422-6273daf7-4658-4431-b591-977bf1004528.png)


상속한다는 의미를 객체 상속의 관점으로 생각한다면 어렵다. 하나의 타입안에 집합 범위라고 생각하여 이를 쉽게 이해 할 수 있게한다.

![스크린샷_2022-05-04_오후_10 31 50](https://user-images.githubusercontent.com/34502254/166692437-1302ea2b-2159-4d70-831e-09d569290332.png)


- 타입스크립트 타입은 엄격한 상속 관계가 아니라. 겹쳐지는 집합으로 표현된다.
- 집합은 유한하거나 무한하다.

## 아이템 8

**타입 공간과 값 공간의 심벌 구분하기**

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

심벌은 이름이 같더라도 속하는 공간에 따라 다른것을 나타낼 수 있다.

instanceof 를 이용하여 타입이 무엇인지 확인하는지 가능하나. 값에 대해 연산을 하기 때문에 함수를 참조하게 된다.

두가지 타입이 있다면, typeof를 사용하는 상황에 따라 다르게 동작할 수 있다.

- as OOO 라고 붙이게 된다면 리터럴 또는 리터럴 표현식이 추론된 타입을 바꾸게 된다.
- extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의 할 수 있다.
    - Generic<T extends number>
- in은 루프 또는 매핑된 타입에 등장하게 된다.

자바스크립트에서 구조 분해 할당이 가능하지만 타입스크립트에서 구조분해 할당으로 적게된다면, 오류가 발생할 수 있다.

그러므로 interface를 사용하거나 type을 미리 정의해 주어 타입을 정의해 주어야 한다.

```tsx
function Email(
 {person, subject, body} : 
 {person:Person, subject: string, body : string}
) {
	...
}
```

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용된다.

## 아이템 9

**타입 단언보다는 타입 선언을 사용하기**

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두가지이다.

```tsx
interface Person {name : string};

const alice: Person = {name : "Alice"}; // 타입 Person
const bob = {name : "Bob"} as Person    // 타입 Person
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.

> const bob = <Person>{} 단언문의 문법이며 , {} as Person 과 동일하다.
> 

타입 단언을 사용하면 런타임에 문제가 발생할 수도 있다. 

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 단언문을 사용하는건은 타당한 방법이다.

- 타입 단언의 as Type 보단  : Type 의 타입 선언을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 잇는 상황에서는 타입 단언문과 null 아님 단언문을 사용한다. ( person! )

## 아이템 10

**객체 래퍼 타입 피하기**

charAt 는 몇번째의 타입을 찾아낼수도 있고 그 타입이라고 정의할 수도 있다.

.charAt(0) 이런식이나 , .charAt(3) 이런식으로 하면 0번 이나 3번의 타입을 알게됨

타입을 정의할때 래퍼 객체는 타입의 구문의 첫 글자를 대문자로 표기하는 방법으로 사용한다. 그러나 타입스크립트 객체 래퍼 타입은 지양하고 기본형 타입을 사용하는것을 권장한다.

# Effective - #2장 타입스크립트의 타입 시스템

# 2장 타입스크립트의 타입 시스템

## 아이템 6

**편집기를 사용하여 타입 시스템 탐색하기**

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용할때에는 에디터에서 코드자동완성, 명세, 검사, 검색, 리팩토링이 가능하다.

마우스를 호버 하고 해당하는 타입이 무엇인지 확인이 가능하다.

![스크린샷 2022-05-04 오후 10.09.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e0af62d-ef88-4a36-9614-962e18fa4d32/스크린샷_2022-05-04_오후_10.09.44.png)

타입이 기대한것과 다르다면 명시적으로 선언이 가능하고, 실제 문제가 발생하는 곳을 찾아볼 수 있다.

객체의 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지도 살펴보는것이 좋다.

라이브러리 혹은 api의 타입이 궁금하다면 해당 노드모듈로 이동해서 타입을 확인하는 방법도 있다.

## 아이템 7

**타입이 값들의 집합이라고 생각하기**

코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있고, 할당 가능한 값들의 집합이 타입이라고 생각하면 된다.

해당한 이 집합은 타입의 범위라고 부르기도 한다.

타입스크립트에서 유닛 타입이라고 불리우는 리터럴 타입

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온타입을 사용한다.

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

`|`  으로 또는 이라는 타입을 선언할 수 있다.

![스크린샷 2022-05-04 오후 10.20.14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df79c7ef-3b21-4c12-8955-88dcd7630666/스크린샷_2022-05-04_오후_10.20.14.png)

인터페이스는 구조적 타이핑 규칙에 의해 어떠한 값이 다른 속성도 가질 수 있음을 의미한다. 

집합의 느낌을 살려, extends키워드를 사용하여 ~에 할당 가능하도록 한다 라는 의미로서 집합이라는 의미로 받아들일 수 있다.

![스크린샷 2022-05-04 오후 10.22.56.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a648e047-eb95-4a25-82b1-896d4a0de4fa/스크린샷_2022-05-04_오후_10.22.56.png)

상속한다는 의미를 객체 상속의 관점으로 생각한다면 어렵다. 하나의 타입안에 집합 범위라고 생각하여 이를 쉽게 이해 할 수 있게한다.

![스크린샷 2022-05-04 오후 10.31.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4c522e3d-ff00-4d60-a6f1-7f0ab754a021/스크린샷_2022-05-04_오후_10.31.50.png)

- 타입스크립트 타입은 엄격한 상속 관계가 아니라. 겹쳐지는 집합으로 표현된다.
- 집합은 유한하거나 무한하다.

## 아이템 8

**타입 공간과 값 공간의 심벌 구분하기**

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

심벌은 이름이 같더라도 속하는 공간에 따라 다른것을 나타낼 수 있다.

instanceof 를 이용하여 타입이 무엇인지 확인하는지 가능하나. 값에 대해 연산을 하기 때문에 함수를 참조하게 된다.

두가지 타입이 있다면, typeof를 사용하는 상황에 따라 다르게 동작할 수 있다.

- as OOO 라고 붙이게 된다면 리터럴 또는 리터럴 표현식이 추론된 타입을 바꾸게 된다.
- extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의 할 수 있다.
    - Generic<T extends number>
- in은 루프 또는 매핑된 타입에 등장하게 된다.

자바스크립트에서 구조 분해 할당이 가능하지만 타입스크립트에서 구조분해 할당으로 적게된다면, 오류가 발생할 수 있다.

그러므로 interface를 사용하거나 type을 미리 정의해 주어 타입을 정의해 주어야 한다.

```tsx
function Email(
 {person, subject, body} : 
 {person:Person, subject: string, body : string}
) {
	...
}
```

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용된다.

## 아이템 9

**타입 단언보다는 타입 선언을 사용하기**

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두가지이다.

```tsx
interface Person {name : string};

const alice: Person = {name : "Alice"}; // 타입 Person
const bob = {name : "Bob"} as Person    // 타입 Person
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.

> const bob = <Person>{} 단언문의 문법이며 , {} as Person 과 동일하다.
> 

타입 단언을 사용하면 런타임에 문제가 발생할 수도 있다. 

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 단언문을 사용하는건은 타당한 방법이다.

- 타입 단언의 as Type 보단  : Type 의 타입 선언을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 잇는 상황에서는 타입 단언문과 null 아님 단언문을 사용한다. ( person! )

## 아이템 10

**객체 래퍼 타입 피하기**

charAt 는 몇번째의 타입을 찾아낼수도 있고 그 타입이라고 정의할 수도 있다.

.charAt(0) 이런식이나 , .charAt(3) 이런식으로 하면 0번 이나 3번의 타입을 알게됨

타입을 정의할때 래퍼 객체는 타입의 구문의 첫 글자를 대문자로 표기하는 방법으로 사용한다. 그러나 타입스크립트 객체 래퍼 타입은 지양하고 기본형 타입을 사용하는것을 권장한다.

## 아이템 11

**잉여 속성 체크의 한계 인지하기**

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립는 해당 타입의 속서이 있는지 그리고 그외의 속성이 없는지 확인한다.

잉여속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워지기에, 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입 시스템에 대한 개념을 잡을 수 있다.

document 나 new HTMLAnchorElement는 객체 리터럴이 아니기 때문에 잉여 속성 체크가 되지 않는다.

잉여 속성 체크는 타입 단언문을 사용할 때에도 적용되지 않습니다.

```tsx
const foo = {x : true , y : "Jang" } as Name ; // 정상
```

잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

구조적 관점에서 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.

공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않습니다.

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름이 오타 같은 실수를 잡는데 효과적인 방법이다.

잉여 속성 체크에는 한계가 있어, 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템 12

**함수 표현식에 타입 적용하기**

자스와 타스에서는 함수 문장과 함수 표현식을 다르게 인식한다.

타입스크립트에서는 함수 표현식을 사용하는 것이 좋으며, 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.

```tsx
type DiceRollFn = (sides :number ) => number;
const rollDice : DiceRollFn = sides => { ... };
```

함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다.
- 다른 함수의 시그니처를 참조하려면 typeof 함수 를 사용하면 된다.

## 아이템 13

**타입과 인터페이스의 차이점 알기**

명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임의 개념이다.

명명된 타입을 정의해 일관성을 유지해야 한다.

- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 타입은 인터페이스를 확장할 수 있다.
- 인터페이스는 타입을 확장할 수 있지만 유니온은 할 수 없다.
- 인터페이스로도 튜플과 비슷하게 구현할 수 있기는 하다.

## 아이템 14

**타입 연산과 제너릭 사용으로 반복 줄이기**

타입중복은 코드 중복만큼 많은 문제를 발생시킨다.

타입에서 중복이 더 흔한 이유중 하나는 공유된 패턴을 제거하는 메커니즘이 기존 코드에서 하던 것과 비교해 덜 익숙하기 때문이다.

반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것이다.

코드는 상수를 사용해서 반복을 줄이는 기법을 동일하게 타입 시스템에 적용한 것이다.

중복된 타입은 찾기가 항상 쉬운 일은 아니다.

매핑된 타입과 keyof를 사용하면 Options으로 부터 OptionsUpdate를 만들 수 있다.

```tsx
type OptionsUpdate = {[k in keyof Options]?: Option[k]};
```

keyof는 타입을 받아서 속성 타입의 유니온을 반환한다.

```tsx
type OptionsKeys = keyof Options;
// 타입이 'width' | 'height' | 'color' | 'labe'
```

매핑된 keyof 은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾고, ?는 각 속성을 선택적으로 만든다.

typeof를 사용하여 제너릭을 사용할 수 있다.

그러나 typeof를 사용한 기법은 신중하게 사용해야 한다. 적용 대상이 값인지 타입인지 정확히 알고 구분해서 처리해야한다.

제너릭 타입에서 매개변수를 제한할 수 있는 방법은 extends를 사용하는 것이다.

extends를 이용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있다.

```tsx
interface Name {
	first : string;
	last : string;
}
type DancingDuo<T extends Name> = [T, T];

const couple1: DancingDuo<Name> = [
	{first : "Fred", last : "Astair" },
	{first : "Ginger" , last : "Rogers" }
]; // OK
```

- 타입들 간의 매핑을 위해 타입스크립트가 제공하는 도구들로 keyof , typeof, 인덱싱이 있다.
- 제너릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는것이 좋다. 제너릭 타입을 제한하려면 extends를 사용하면 된다.
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 한다.

## 아이템 15

**동적 데이터에 인덱스 시그니처 사용하기**

자바스크립트의 장점 중 하나는 바로 객체를 생성하는 문법이 간단하다.

```tsx
type Rocket = {[property: string]:string};
const rocket: Rocket = {
	name : "Falcon 9",
	variant : "v1.0",
	thrust: "4,940 kN",
};
```

[property: string]: string 이 인덱스 시그니처이며 다음 세가지를 의미한다.

- 키의 이름 : 키의 위치만 표시하는 용도이며, 타입 체커에서는 사용하지 않는다.
- 키의 타입 : string이나, number 또는 symbol의 조합이어야 하지만 보통은 string을 사용한다.
- 값의 타입 : 어떤 것이든 될 수 있다.

이 후 4가지 단점이 드러나게 된다.

1. 잘못된 키를 포함해 모든 키를 허용한다.
2. 특정 키가 필요하지 않는다.
3. 키마다 다른 타입을 가질 수 없다.
4. 타입스크립트 언어 서비스는 키가 무엇이든 가능하기에 저동완성 기능이 동작 안한다.

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용한다.
- 안전한 접근을 위해 인덱스 시그니처 값 타입에 undefined를 추가하는 것을 고려해야 한다.
- 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

# Effective - #2장 타입스크립트의 타입 시스템

![327754-eng](https://user-images.githubusercontent.com/34502254/166692339-dad60070-d050-4f7e-8429-a3c197a2d55a.png)

# 2장 타입스크립트의 타입 시스템

## 아이템 6

**편집기를 사용하여 타입 시스템 탐색하기**

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용할때에는 에디터에서 코드자동완성, 명세, 검사, 검색, 리팩토링이 가능하다.

마우스를 호버 하고 해당하는 타입이 무엇인지 확인이 가능하다.

![스크린샷_2022-05-04_오후_10 09 44](https://user-images.githubusercontent.com/34502254/166692374-1657a848-87a2-4289-a087-a0d486c0f099.png)

타입이 기대한것과 다르다면 명시적으로 선언이 가능하고, 실제 문제가 발생하는 곳을 찾아볼 수 있다.

객체의 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지도 살펴보는것이 좋다.

라이브러리 혹은 api의 타입이 궁금하다면 해당 노드모듈로 이동해서 타입을 확인하는 방법도 있다.

## 아이템 7

**타입이 값들의 집합이라고 생각하기**

코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있고, 할당 가능한 값들의 집합이 타입이라고 생각하면 된다.

해당한 이 집합은 타입의 범위라고 부르기도 한다.

타입스크립트에서 유닛 타입이라고 불리우는 리터럴 타입

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온타입을 사용한다.

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

`|`  으로 또는 이라는 타입을 선언할 수 있다.

![스크린샷_2022-05-04_오후_10 20 14](https://user-images.githubusercontent.com/34502254/166692396-796d4f9f-08ca-4a7d-9679-9987fb4ef0d9.png)

인터페이스는 구조적 타이핑 규칙에 의해 어떠한 값이 다른 속성도 가질 수 있음을 의미한다. 

집합의 느낌을 살려, extends키워드를 사용하여 ~에 할당 가능하도록 한다 라는 의미로서 집합이라는 의미로 받아들일 수 있다.

![스크린샷_2022-05-04_오후_10 22 56](https://user-images.githubusercontent.com/34502254/166692422-6273daf7-4658-4431-b591-977bf1004528.png)


상속한다는 의미를 객체 상속의 관점으로 생각한다면 어렵다. 하나의 타입안에 집합 범위라고 생각하여 이를 쉽게 이해 할 수 있게한다.

![스크린샷_2022-05-04_오후_10 31 50](https://user-images.githubusercontent.com/34502254/166692437-1302ea2b-2159-4d70-831e-09d569290332.png)


- 타입스크립트 타입은 엄격한 상속 관계가 아니라. 겹쳐지는 집합으로 표현된다.
- 집합은 유한하거나 무한하다.

## 아이템 8

**타입 공간과 값 공간의 심벌 구분하기**

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

심벌은 이름이 같더라도 속하는 공간에 따라 다른것을 나타낼 수 있다.

instanceof 를 이용하여 타입이 무엇인지 확인하는지 가능하나. 값에 대해 연산을 하기 때문에 함수를 참조하게 된다.

두가지 타입이 있다면, typeof를 사용하는 상황에 따라 다르게 동작할 수 있다.

- as OOO 라고 붙이게 된다면 리터럴 또는 리터럴 표현식이 추론된 타입을 바꾸게 된다.
- extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의 할 수 있다.
    - Generic<T extends number>
- in은 루프 또는 매핑된 타입에 등장하게 된다.

자바스크립트에서 구조 분해 할당이 가능하지만 타입스크립트에서 구조분해 할당으로 적게된다면, 오류가 발생할 수 있다.

그러므로 interface를 사용하거나 type을 미리 정의해 주어 타입을 정의해 주어야 한다.

```tsx
function Email(
 {person, subject, body} : 
 {person:Person, subject: string, body : string}
) {
	...
}
```

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용된다.

## 아이템 9

**타입 단언보다는 타입 선언을 사용하기**

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두가지이다.

```tsx
interface Person {name : string};

const alice: Person = {name : "Alice"}; // 타입 Person
const bob = {name : "Bob"} as Person    // 타입 Person
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.

> const bob = <Person>{} 단언문의 문법이며 , {} as Person 과 동일하다.
> 

타입 단언을 사용하면 런타임에 문제가 발생할 수도 있다. 

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 단언문을 사용하는건은 타당한 방법이다.

- 타입 단언의 as Type 보단  : Type 의 타입 선언을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 잇는 상황에서는 타입 단언문과 null 아님 단언문을 사용한다. ( person! )

## 아이템 10

**객체 래퍼 타입 피하기**

charAt 는 몇번째의 타입을 찾아낼수도 있고 그 타입이라고 정의할 수도 있다.

.charAt(0) 이런식이나 , .charAt(3) 이런식으로 하면 0번 이나 3번의 타입을 알게됨

타입을 정의할때 래퍼 객체는 타입의 구문의 첫 글자를 대문자로 표기하는 방법으로 사용한다. 그러나 타입스크립트 객체 래퍼 타입은 지양하고 기본형 타입을 사용하는것을 권장한다.

# Effective - #2장 타입스크립트의 타입 시스템

# 2장 타입스크립트의 타입 시스템

## 아이템 6

**편집기를 사용하여 타입 시스템 탐색하기**

- 타입스크립트 컴파일러(tsc)
- 단독으로 실행할 수 있는 타입스크립트 서버(tsserver)

타입스크립트를 사용할때에는 에디터에서 코드자동완성, 명세, 검사, 검색, 리팩토링이 가능하다.

마우스를 호버 하고 해당하는 타입이 무엇인지 확인이 가능하다.

![스크린샷 2022-05-04 오후 10.09.44.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e0af62d-ef88-4a36-9614-962e18fa4d32/스크린샷_2022-05-04_오후_10.09.44.png)

타입이 기대한것과 다르다면 명시적으로 선언이 가능하고, 실제 문제가 발생하는 곳을 찾아볼 수 있다.

객체의 개별 속성을 살펴봄으로써 타입스크립트가 어떻게 각각의 속성을 추론하는지도 살펴보는것이 좋다.

라이브러리 혹은 api의 타입이 궁금하다면 해당 노드모듈로 이동해서 타입을 확인하는 방법도 있다.

## 아이템 7

**타입이 값들의 집합이라고 생각하기**

코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 타입을 가지고 있고, 할당 가능한 값들의 집합이 타입이라고 생각하면 된다.

해당한 이 집합은 타입의 범위라고 부르기도 한다.

타입스크립트에서 유닛 타입이라고 불리우는 리터럴 타입

```tsx
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온타입을 사용한다.

```tsx
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
```

`|`  으로 또는 이라는 타입을 선언할 수 있다.

![스크린샷 2022-05-04 오후 10.20.14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/df79c7ef-3b21-4c12-8955-88dcd7630666/스크린샷_2022-05-04_오후_10.20.14.png)

인터페이스는 구조적 타이핑 규칙에 의해 어떠한 값이 다른 속성도 가질 수 있음을 의미한다. 

집합의 느낌을 살려, extends키워드를 사용하여 ~에 할당 가능하도록 한다 라는 의미로서 집합이라는 의미로 받아들일 수 있다.

![스크린샷 2022-05-04 오후 10.22.56.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a648e047-eb95-4a25-82b1-896d4a0de4fa/스크린샷_2022-05-04_오후_10.22.56.png)

상속한다는 의미를 객체 상속의 관점으로 생각한다면 어렵다. 하나의 타입안에 집합 범위라고 생각하여 이를 쉽게 이해 할 수 있게한다.

![스크린샷 2022-05-04 오후 10.31.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4c522e3d-ff00-4d60-a6f1-7f0ab754a021/스크린샷_2022-05-04_오후_10.31.50.png)

- 타입스크립트 타입은 엄격한 상속 관계가 아니라. 겹쳐지는 집합으로 표현된다.
- 집합은 유한하거나 무한하다.

## 아이템 8

**타입 공간과 값 공간의 심벌 구분하기**

타입스크립트의 심벌은 타입 공간이나 값 공간 중의 한 곳에 존재한다.

심벌은 이름이 같더라도 속하는 공간에 따라 다른것을 나타낼 수 있다.

instanceof 를 이용하여 타입이 무엇인지 확인하는지 가능하나. 값에 대해 연산을 하기 때문에 함수를 참조하게 된다.

두가지 타입이 있다면, typeof를 사용하는 상황에 따라 다르게 동작할 수 있다.

- as OOO 라고 붙이게 된다면 리터럴 또는 리터럴 표현식이 추론된 타입을 바꾸게 된다.
- extends는 서브클래스 또는 서브타입 또는 제너릭 타입의 한정자를 정의 할 수 있다.
    - Generic<T extends number>
- in은 루프 또는 매핑된 타입에 등장하게 된다.

자바스크립트에서 구조 분해 할당이 가능하지만 타입스크립트에서 구조분해 할당으로 적게된다면, 오류가 발생할 수 있다.

그러므로 interface를 사용하거나 type을 미리 정의해 주어 타입을 정의해 주어야 한다.

```tsx
function Email(
 {person, subject, body} : 
 {person:Person, subject: string, body : string}
) {
	...
}
```

- 모든 값은 타입을 가지지만, 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum 같은 키워드는 타입과 값 두가지로 사용된다.

## 아이템 9

**타입 단언보다는 타입 선언을 사용하기**

타입스크립트에서 변수에 값을 할당하고 타입을 부여하는 방법은 두가지이다.

```tsx
interface Person {name : string};

const alice: Person = {name : "Alice"}; // 타입 Person
const bob = {name : "Bob"} as Person    // 타입 Person
```

타입 선언은 할당되는 값이 해당 인터페이스를 만족하는지 검사한다.

> const bob = <Person>{} 단언문의 문법이며 , {} as Person 과 동일하다.
> 

타입 단언을 사용하면 런타임에 문제가 발생할 수도 있다. 

타입스크립트는 DOM에 접근할 수 없기 때문에 타입 단언문을 사용하는건은 타당한 방법이다.

- 타입 단언의 as Type 보단  : Type 의 타입 선언을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 한다.
- 타입스크립트보다 타입 정보를 더 잘 알고 잇는 상황에서는 타입 단언문과 null 아님 단언문을 사용한다. ( person! )

## 아이템 10

**객체 래퍼 타입 피하기**

charAt 는 몇번째의 타입을 찾아낼수도 있고 그 타입이라고 정의할 수도 있다.

.charAt(0) 이런식이나 , .charAt(3) 이런식으로 하면 0번 이나 3번의 타입을 알게됨

타입을 정의할때 래퍼 객체는 타입의 구문의 첫 글자를 대문자로 표기하는 방법으로 사용한다. 그러나 타입스크립트 객체 래퍼 타입은 지양하고 기본형 타입을 사용하는것을 권장한다.

## 아이템 11

**잉여 속성 체크의 한계 인지하기**

타입이 명시된 변수에 객체 리터럴을 할당할 때 타입스크립는 해당 타입의 속서이 있는지 그리고 그외의 속성이 없는지 확인한다.

잉여속성 체크 역시 조건에 따라 동작하지 않는다는 한계가 있고, 통상적인 할당 가능 검사와 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워지기에, 잉여 속성 체크가 할당 가능 검사와는 별도의 과정이라는 것을 알아야 타입 시스템에 대한 개념을 잡을 수 있다.

document 나 new HTMLAnchorElement는 객체 리터럴이 아니기 때문에 잉여 속성 체크가 되지 않는다.

잉여 속성 체크는 타입 단언문을 사용할 때에도 적용되지 않습니다.

```tsx
const foo = {x : true , y : "Jang" } as Name ; // 정상
```

잉여 속성 체크를 원치 않는다면, 인덱스 시그니처를 사용해서 타입스크립트가 추가적인 속성을 예상하도록 할 수 있다.

구조적 관점에서 타입은 모든 속성이 선택적이므로 모든 객체를 포함할 수 있다.

공통 속성 체크는 잉여 속성 체크와 마찬가지로 오타를 잡는 데 효과적이며 구조적으로 엄격하지 않습니다.

잉여 속성 체크는 구조적 타이핑 시스템에서 허용되는 속성 이름이 오타 같은 실수를 잡는데 효과적인 방법이다.

잉여 속성 체크에는 한계가 있어, 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템 12

**함수 표현식에 타입 적용하기**

자스와 타스에서는 함수 문장과 함수 표현식을 다르게 인식한다.

타입스크립트에서는 함수 표현식을 사용하는 것이 좋으며, 함수의 매개변수 부터 반환값까지 전체를 함수 타입으로 선언하여 함수 표현식에 재사용할 수 있다는 장점이 있다.

```tsx
type DiceRollFn = (sides :number ) => number;
const rollDice : DiceRollFn = sides => { ... };
```

함수 타입의 선언은 불필요한 코드의 반복을 줄인다.

반복되는 함수 시그니처를 하나의 함수 타입으로 통합할 수도 있다.

- 매개변수나 반환 값에 타입을 명시하기보다는 함수 표현식 전체에 타입 구문을 적용하는 것이 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 합니다.
- 다른 함수의 시그니처를 참조하려면 typeof 함수 를 사용하면 된다.

## 아이템 13

**타입과 인터페이스의 차이점 알기**

명명된 타입을 정의할 때 인터페이스 대신 클래스를 사용할 수도 있지만, 클래스는 값으로도 쓰일 수 있는 자바스크립트 런타임의 개념이다.

명명된 타입을 정의해 일관성을 유지해야 한다.

- 타입 별칭과 인터페이스는 모두 제너릭이 가능하다.
- 타입은 인터페이스를 확장할 수 있다.
- 인터페이스는 타입을 확장할 수 있지만 유니온은 할 수 없다.
- 인터페이스로도 튜플과 비슷하게 구현할 수 있기는 하다.

## 아이템 14

**타입 연산과 제너릭 사용으로 반복 줄이기**

타입중복은 코드 중복만큼 많은 문제를 발생시킨다.

타입에서 중복이 더 흔한 이유중 하나는 공유된 패턴을 제거하는 메커니즘이 기존 코드에서 하던 것과 비교해 덜 익숙하기 때문이다.

반복을 줄이는 가장 간단한 방법은 타입에 이름을 붙이는 것이다.

코드는 상수를 사용해서 반복을 줄이는 기법을 동일하게 타입 시스템에 적용한 것이다.

중복된 타입은 찾기가 항상 쉬운 일은 아니다.

매핑된 타입과 keyof를 사용하면 Options으로 부터 OptionsUpdate를 만들 수 있다.

```tsx
type OptionsUpdate = {[k in keyof Options]?: Option[k]};
```

keyof는 타입을 받아서 속성 타입의 유니온을 반환한다.

```tsx
type OptionsKeys = keyof Options;
// 타입이 'width' | 'height' | 'color' | 'labe'
```

매핑된 keyof 은 순회하며 Options 내 k 값에 해당하는 속성이 있는지 찾고, ?는 각 속성을 선택적으로 만든다.

typeof를 사용하여 제너릭을 사용할 수 있다.

그러나 typeof를 사용한 기법은 신중하게 사용해야 한다. 적용 대상이 값인지 타입인지 정확히 알고 구분해서 처리해야한다.

제너릭 타입에서 매개변수를 제한할 수 있는 방법은 extends를 사용하는 것이다.

extends를 이용하면 제너릭 매개변수가 특정 타입을 확장한다고 선언할 수 있다.

```tsx
interface Name {
	first : string;
	last : string;
}
type DancingDuo<T extends Name> = [T, T];

const couple1: DancingDuo<Name> = [
	{first : "Fred", last : "Astair" },
	{first : "Ginger" , last : "Rogers" }
]; // OK
```

- 타입들 간의 매핑을 위해 타입스크립트가 제공하는 도구들로 keyof , typeof, 인덱싱이 있다.
- 제너릭 타입은 타입을 위한 함수와 같다. 타입을 반복하는 대신 제너릭 타입을 사용하여 타입들 간에 매핑을 하는것이 좋다. 제너릭 타입을 제한하려면 extends를 사용하면 된다.
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType 같은 제너릭 타입에 익숙해져야 한다.

## 아이템 15

**동적 데이터에 인덱스 시그니처 사용하기**

자바스크립트의 장점 중 하나는 바로 객체를 생성하는 문법이 간단하다.

```tsx
type Rocket = {[property: string]:string};
const rocket: Rocket = {
	name : "Falcon 9",
	variant : "v1.0",
	thrust: "4,940 kN",
};
```

[property: string]: string 이 인덱스 시그니처이며 다음 세가지를 의미한다.

- 키의 이름 : 키의 위치만 표시하는 용도이며, 타입 체커에서는 사용하지 않는다.
- 키의 타입 : string이나, number 또는 symbol의 조합이어야 하지만 보통은 string을 사용한다.
- 값의 타입 : 어떤 것이든 될 수 있다.

이 후 4가지 단점이 드러나게 된다.

1. 잘못된 키를 포함해 모든 키를 허용한다.
2. 특정 키가 필요하지 않는다.
3. 키마다 다른 타입을 가질 수 없다.
4. 타입스크립트 언어 서비스는 키가 무엇이든 가능하기에 저동완성 기능이 동작 안한다.

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 인덱스 시그니처를 사용한다.
- 안전한 접근을 위해 인덱스 시그니처 값 타입에 undefined를 추가하는 것을 고려해야 한다.
- 가능하다면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

## 아이템 16

**number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기**

숫자는 키로 사용할 수 없다. 숫자로 사용하려고 하면 자바스크립트 런타임은 문자열로 반환한다.

배열의 요소에 접근할때는 숫자로 인덱스를 사용하는것은 당연하나. 인덱스들은 문자열로 변환되어 사용된다.

- 인덱스에 신경 쓰지 않는다면 for-of를 사용하는게 좋다.
- 인덱스의 타입이 중요하다면 Array.prototype.forEach를 사용한다.
- 루프 중간에 멈춰야 한다면 for루프를 사용하는것이 좋다.
- 타입이 불확실하다면, for-in 루프는 for-of 또는 for 루프에 비해 몇 배나 느리다.

**어떤 길이를 가지는 배열과 비슷한 형태의 튜플을 사용하고 싶다면 타입스크립트에 있는 ArrayLike 타입을 사용한다.**

```tsx
function checkedAccess<T>(xs: ArrayLike<T>, i : number): T {
	if(i < xs.length) {
		return xs[i];
	}
	throw new Error(`배열의 끝을 지나서 ${i}를 접근하려고 했습니다.`)
}

```

- 배열은 객체이므로 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다.
- 인덱스 시그니처에 number 를 사용하기 보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.

## 아이템 17

**변경 관련된 오류 방지를 위해 readonly 사용하기**

```tsx
function arraySum(arr: readonly number[]) {
	let sum = 0 , num ;
	while((num = arr.pop()) !== undefined) {
		sum += num;
	}
	return sum;
}
```

타입 단언문 없이 readonly 접근제어자를 제거할 수 있다면 readonly는 쓸모 없다.

- readonly는 읽을 수는 있는지만 수정하여 사용은 못한다.
- 매개변수가 함수 내에서 변경이 일어나는지 확인한다.
- 내장 메서드는 사용이 가능하다.
- 변경하면서 발생하는 오류 체크와, 변경이 발생하는 코드를 찾을 수 있다.

### 올바른 readonly 예시

```tsx
function arraySum(arr: readonly number[]) {
	let sum = 0
	for(const num of arr) {
		sum += num;
	}
	return sum;
}
```

함수가 매개변수를 변경하지 않는다면 readonly로 선언해야 한다.

더 넓은 타입으로 호출할 수 있고, 의도치 않은 변경은 방지될 것이다.

readonly는 얕게 동작하기에 깊은 뎁스가 있는 배열 혹은 객체라면, readonly의 사촌격인 `Readonly 제너릭` 을 사용해서 객체의 타입을 지정해 주면 된다.

```tsx
interface Outer {
	inner : {
	x : number ;
	}
}

const o : Readonly<Outer> = {inner : { x : 0 } };
```

readonly가 기본적으로 읽기 속성이기 때문에 해당 inner에 할당할 수 없기 때문에,

o.inner.x = 1  라고 명시해줘야 한다.

기본적으로 깊은 뎁스에서 readonly 타입이 기본으로 지원되지 않지만, 제너릭으로 만들수 있다. 그러나, 제너릭을 만들기가 까다롭기 때문에 타입스크립트 관련 라이브러리를 사용하는게 좋다.
	
## 아이템 18

**매핑된 타입을 사용하여 값을 동기화하기**

### 타입을 최적화 하는 방법.

**보수적 접근법**

```tsx
function shouldUpadte(
	oldProps : ScatterProps,
	newProps : ScatterProps,
) {
	let k : keyof ScatterProps;
	for ( k in oldProps ) {
		if (oldProps[k] !== newProps[k]) {
			if (k !== 'onClick') return true;
		}
	}
	return false;
}
```

만약 새로운 속성이 추가되면 shouldUpdate 함수는 값이 변경될 때마다 차트를 다시 그린다.

이렇게 처리하는 것을 보수적 접근법 또는 실패에 닫힌 접근법이라고 한다.

보수적 접근법 : conservative

실패에 닫힌 접근법 : fail close

**실패에 열린 접근법**

```tsx
function shouldUpadte(
	oldProps : ScatterProps,
	newProps : ScatterProps,
) {
	return (
		oldProps.xs !== newProps.xs ||
		oldProps.ys !== newProps.ys ||
		oldProps.xRange !== newProps.xRange ||
		oldProps.yRange !== newProps.yRange ||
		oldProps.color !== newProps.color ||
	)
}
```

차트를 불필요하게 다시 그리는 단점을 해결하였으나, 실제로 차트를 다시 그려야 할 경우에는 누락되는 일이 생길 수 있다.

이 두가지 방법을 해결할 수 있는 방법으로 타입체커가 대신할 수 있게 하는 것이 좋다.

```tsx
interface ScatterProsp {
	xs : number[];
	ys : number[];
...
	onClick (x : number, y: number, index :number ) => void
}
```

- 매핑된 타입을 사용해서 관련된 값과 타입을 동기화하도록 하자.
- 인터페이스에 새로운 속성을 추가할 때 선택을 강제하도록 매핑된 타입을 고려하자.
