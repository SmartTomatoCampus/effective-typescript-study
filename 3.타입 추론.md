# Effective - #3장 타입 추론

![327754-eng](https://user-images.githubusercontent.com/34502254/168100406-8929de59-6ccb-4f91-981f-f520586eaf70.png)

## 아이템 19

**추론 가능한 타입을 사용해 장황한 코드 방지하기**

```tsx
let x :number = 12; 
```

이렇게만 하여도 타입스크립트를 잘 사용하고 있는 것이다.

타입 추론이 된다면 명시적 타입 구문은 필요하지 않는다. 오히려 방해가 될 뿐이다.

만약 타입을 확신하지 못한다면 편집기를 통해 체크하면 된다.

타입이 추론되면 리팩토링 역시 용이해진다.

```tsx
interface Product {
	id : number;
	name : string;
	price : number;
}

function logProduct(product : Product) {
	const id: number = product.id;
	const name : string = product.name;
	const price : number = product.price;
	console.log(id, name, price);
}
```

만약 id에 number 가 아닌 string이 들어간다고 가정하면, 오류가 뜨게 되고, 명시적이 아니라면 괜찮게 넘어갔을 것이다.

이를 방지하기 ? 위해서 비구조화 할당문을 사용해 구현하는게 좋다.

```tsx
function logProduct(product: Product) {
	const { id, name, price } = product;
	console.log(id, name, price);
}
```

```tsx
const cache: {[ticker:string] : string} = {};
function getQuote(ticker : string): Promise<number> {
	if( ticker in cache ) {
		return cache[ticker];
	}
}
```

반환 타입을 명시하면 구현상의 오류가 사용자 코드의 오류로 표시되지 않는다.

오류의 위치를 제대로 표시해 주는 이점 외에도 반환타입을 명시해야 하는 이유가 두가지 있다.

1. 반환 타입을 명시하면 함수에 대해 더욱 명확하게 알 수 있기 때문이다.
    1. 반환 타입을 명시하려면 구현하기 전에 입력 타입과 출력 타입이 무엇인지 알아야 하낟.
    2. 미리 타입을 명시하는 방법은, 함수를 구현하기 전에 테스트를 먼저 작성하는 테스트 주도 개발과 비슷하다.
2. 명명된 타입을 사용하기 위해서 이다.
    1. 반환 타입을 명시하면 더욱 직관적인 표현이 된다.
    2. 추론된 반환 타입이 복잡해질수록 명명된 타입을 제공하는 이점은 커진다.

- 타입스크립트가 타입을 추론할 수 있다면 타입구문을 작성하지 말아라
- 함수 메서드의 시그니처에는 타입 구문이 있지만 함수 내의 지역 변수에는 타입 구문이 없다.
- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야 한다.

## 아이템 20

**다른 타입에는 다른 변수 사용하기**

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른 타입으로 재사용해도 된다.

다른 타입에는 별도의 변수를 사용하는게 바람직한 이유

- 관련이 없는 변수라면 타입은 분리해서 값을 적용시켜야 한다.
- 타입 추론을 향상시키며 타입 구문이 불필요하다.
- 변수명을 더 구체적으로 지을 수 있다.
- 타입이 좀 더 간결해진다.
- const 로 변수를 지정하면 간결해지고 타입 체커가 추론하기에도 좋다.

변수의 값은 바뀔 수 있지만, 타입은 일반적으로 바뀌지 아니한다.

혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 한다.

## 아이템 21 타입 넓히기

런타임에 모든 변수는 유일한 값을 가진다. 그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에 변수는 가능한 값들의 집합인 타입을 가진다.

상수를 사용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입 체커는 타입을 결정해야 한다. 즉, 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야 한다.

타입스크립트에서는 이러한 과정을 넓히기라고 부르고, 넓히기 과정을 이해한다면 오류의 원인을 파악하고 타입 구문을 더 효과적으로 사용할 수 있다.

타입스크립트는 넓히기 과정을 제어할 수 있도록 몇가지 제공한다.

1. const를 사용해서 더 좁은 타입이 된다.
    1. 타입의 오류를 해결할 수도 있다.

```tsx
const x = "x";
let vec = { x : 10, y : 20, z : 30 };
getComponent(vec, x);
```

1. 추가적인 문맥을 제공하는 것이다. 함수의 매개변수로 값을 전달하는 방법.
2. const 단언문을 사용하는 것이다.
    1. const 단언문과 변수 선언에 쓰이는 let이나 const와 혼동해서는 안된다.
    2. const 단언문은 온전히 타입 공간의 기법이다.

```tsx
const v1 = {
	x : 1,
	y : 2,
};

const v2 = {
	x : 1 as const,
	y : 2,
};

const v3 = {
	x : 1,
	y : 2,
} as const;
```

const 을 붙이게 되면, 타입스크립트는 최대한 좁은 타입으로 추론한다.

- 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법을 이해해야 한다.
- 동작에 영향을 줄 수 있는 방법인 const 타입 구문, 문맥 as const에 익숙해져야 한다.

## 아이템 22

**타입 좁히기**

일반적인 예시로는 null 체크이다.

```tsx
const el = document.getElementById('foo');
// HTMLElement | null
if(el) {
	el
	el.innerHTML = "Party Time".blink();
// HTMLElement
} else {
	el
	alert("No element #foo");
}
// null
```

null 이라면 블록은 실행되지 않는다. null 타입을 미리 알고 있기에 더 좁은 타입이 되어 작업이 훨씬 쉬워진다.

이러한 방법은 분기문에서 예외를 던지거나 함수를 반환하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수도 있다.

```tsx
const el = document.getElementById("foo");
//HTMLElement | null
if(!el) throw new Error("Unable to find #foo");
el;
// HTMLElement
el.innerHTML = "Party Time".blink();
```

미리 null (!) 로 표기후 에러를 반환하였기에 더욱 더 좁히게 되었다.

그외 타입을 좁힐수 있는 방법으로

- instanceof 타입체커를 통해 타입을 좁힐수도 있다.
- 속성 체크로도 타입을 좁힐 수도 있다.
- Array.isArray 같은 일부 내장함수로도 타입을 좁힐 수도 있다.
- 조건문에서 타입을 좁히는데 매우 능숙하다.
- 명시적 태그를 붙이는 방법도 타입을 좁히는 방법이다.

만약 타입스크립트가 타입을 식별하지 못한다면 식별을 돕기 위해 커스텀 함수를 도입할 수 잇다.

```tsx
function isInputElement(el: HTMLelement) : el is HTMLInputElemet {
	return "value" in el;
}

function getElementContent(el: HTMLElement) {
	if(isInputElement(el)) {
		el; // HTMLInputElement
		return el.value
	}
	el; // HTMLElement
	return el.textContent;
}
```

이러한 기법을 사용자 정의 타입 가드라고 한다.

el is HTMLInputElement 는 함수의 반환이 true인 경우 타입 체커에게 매개변수의 타입을 좁힐 수 있다고 알려준다.

어떤 함수들은 타입 가드를 사용하여 배열과 객체의 타입 좁히기를 할수 있다.

- 편집기에서 타입을 조사하는 습관을 지니면 타입 좁히기가 어떻게 동작하는지 자연스레 익힐 수 있다.
- 분기문 외에도 여러 종류의 제어 흐름을 살펴보며 타입스크립트가 타입을 좁히는 과정을 이해해야 한다.
- 태그된 구별된 유니온과 사용자 정의 타입 가드를 사용하여 타입 좁히기 과정을 원활하게 만들 수 있다.

## 아이템 23

**한꺼번에 객체 생성하기**

타입스크립트 타입은 일반적으로 변경되지 않아, 자바스크립트 패턴을 타입스크립트로 모델링하는게 쉽다.

즉 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 한꺼번에 생성해야 타입 추론에 유리하다.

```tsx
interface Point ( x: number , y:number };

const pt = {
	x : 3,
	y : 4,
};

as 를 사용하여 타입체커를 통과하게 만들수도 있다.

const pt = {} as Point;
pt.x = 3;
pt.y = 4;

// 위와 아래는 같다.

const pt: Point = {
	x : 3, 
	y : 4,
}
```

객체 전개 연산자를 통해 큰 객체를 한꺼번에 만들어 낼수도 있다.

```tsx
const namedPoint = {...pt, ...id}
namedPoint.name // type string 
```

타입에 안전한 방식으로 조건부 속성을 추가하려면 속성을 추가하지 않는 null 또는 {} 으로 객체 전개를 사용하면 된다.

```tsx
declare let hasMiddle : boolean;
const firstLast = {first : "Harry" , last : "Truman" };
const president = {
	...firstLast,
	...(hasMiddle 
	? {middle: "S" } 
	: {})
};
```

전개 연산자로 한꺼번에 여러 속성을 추가할수도 있다는 것이다. 

유니온보다 선택적 필드를 다루기에 더 쉽기 때문에 선택적 필드 방식으로 표현하려면 헬퍼 함수를 사용하면 된다.

```tsx
function addOptional<T extends object, U extends object>(
	a: T, b: U | null
) : T & Partial<U> {
	return {...a, ...b};
}
const pharaoh = addOptional(
	nameTitle,
	hasDates ? { start: -2578 , end : -2524 } : null
);
pharaoh.start // 정상 타입이 number | undefined
```

- 속성을 제각각 추가하지 말고 한꺼번에 객체로 만들어야 한다.
- 안전한 타입으로 속성을 추가하려면 객체 전개를 사용하면 된다.
- 객체에 조건부로 속성을 추가하는 방법을 익히자.

## 아이템 24

**일관성 있는 별칭 사용하기**

하나의 객체의 변수를 만들어 할당하여 그 타입을 변경하면 원래 속성값에서도 변경하게 된다.

별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵기에 별칭을 신중하게 사용해야 한다.

타입을 자료구조형으로 사용하여 속성을 빠르게 체크할수 있다.

```tsx
interface Coordinate {
	x : number;
	y : number;
}

interface BoundingBox {
	x : [number , number];
	y : [number , number];
}

interface Polygon {
	exterior : Coordinate[];
	holes : Coordinate[][];
	bbox? : BoundingBox;
}
```

객체 비구조화를 이용할 때는 두가지를 주의해야한다.

- 전체 속성이 아니라 각 속해 있는 선택적 속성일 경우에 속성 체크가 더 필요하기에 타입 경계에 null 값을 추가하는 것이 좋다.
- 선택적 속성이 적합하다고 생각하지만, 안에 속해 있는 별칭이 선택적이라면 값이 겂거나 빈 배열이 될 것이다.

- 별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.
- 비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.
- 함수 호출이 객체 속성의 타입 정제를 무효화 할 수 있다는 점을 주의해야 한다.
- 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.
