# Effective - #5장 any 다루기

![327754-eng](https://user-images.githubusercontent.com/34502254/168100406-8929de59-6ccb-4f91-981f-f520586eaf70.png)

## 아이템 38

any 타입은 가능한 한 좁은 범위에서만 사용하기

```tsx
const x : any 이렇게 쓰지말고, x as any 이렇게 사용해라 
```

전체에 as any 보다는 최소한의 속성 하나에면 as any를 적용시켜 주는것이 좋다.

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 한다.
- 함수의 반환 타입이 any인 경우 타입 안전성이 나빠진다.
- any 타입을 반환하면 절대 안된다.
- 강제로 타입 오류를 제거하려면 any 대신 `@ts-ginore` 을 사용하는 것이 좋다.


## 아이템 39

**any를 구체적으로 변형해서 사용하기**

any는 모든 값을 아우르는 매우 큰 범위의 타입이다. 

자바스크립트의 기본 오퍼레이터는 타입을 가지고 있기에 타입을 적어주지 않아도 된다.

배열형태가 any[][]인 경우라면, for in 으로 key 값을 넣어주어야 한다.

any보다 더 정확하게 모델링할 수 있도록 any[] 또는`{[id : string ] : any }` 또는 `() ⇒ any` 처럼 구체적인 형태를 사용해야 한다.


## 아이템 40

**함수 안으로 타입 단언문 감추기**

- 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상황까지 고려해 가며 타입 정보를 힘들게 구성할 필요는 없다.
- 함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는게 좋다.
- 타입 선언문은 일반적으로 타입을 위험하게 만드지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다.
- 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 해야한다.

## 아이템 41

**any의 진화를 이해하기**

예를 들어 number라고 정의했지만, 함수에 의해서 number[]라고 타입이 추론이 될수 있다.

이러한 타입은 진화라고 말한다.

타입의 진화는 타입 좁히기와는 다르다. 배열에 다양한 타입의 요소를 넣으면 배열의 타입이 확장되며 진화한다.

- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있습니다.
- 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 한다.
- any를 진화시키는 방식보다 명시적 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.
