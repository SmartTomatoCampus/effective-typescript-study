# 뽀또

## 아이템 31

타입 주변에 null 값 배치하기

값이 전부 null 이거나 전부 null이 아닌 경우로 분명히 구분된다면, 값이 섞여 있을 때보다 다루기가 쉽다. 

타입에 null을 추가하는 방식으로 이러한 경우를 모델링 할 수 있다.

null 아님 단언 대신 단순 if구문으로 체크할 수도 있다.

null은 2개의 타입이 존재하는 나와 null 인경우에만 사용해야 적극적으로 활용할 수 있다. 타입이 여러개이거나, 속성값이 불확실성한 값이라면 버그를 양산하게 된다.

null 인 경우가 필요한 속성은 프로미스로 바꾸면 안된다. 코드가 복잡해지고 모든 매서드가 비동기로 바뀌어야 한다.

# 너두

## 아이템 31 타입 주변에 null 값 배치하기

- undefined를 포함하는 객체는 다루기 어렵고 권장하지 않음
- strictNullChecks를 켜면 이전에 if null 처리 or null이 없거나 null만 있거나의 처리에서 타입 시스템으로 표현할 수 없다.
1. [number, number] | null 사용
2. example! 사용하여 min max 얻기
3. if구문으로 체크
- null과 값을 섞어서 사용하면 클래스 역시 문제가 생긴다 ⇒ null체크 난무+버그양산
- 필요데이터가 준비된 후 클래스를 만들도록 설계(초기값이 string)
- null인 경우가 필요한 속성은 프로미스로 바꾸면 안됨 ⇒ 복잡해짐+비동기처리


# 삼앵

## 아이템 31 타입주변에 null 값 배치하기

- 한 값의 null여부가 다른 값의 null여부에 암시적으로 관련되도록 설계하지말자
- strictNullChecks를 설정하면 코드에 많은 오류가 표시되겠지만 null값과 관련된 문제점을 찾아낼수있기 떄문에 반드시 필요하다. (ts환경설정)
- API 작성시에는 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야한다.

# 애한

## item 31 타입 주변에 null 값 배치하기

한 값의 null 여부가 다른 값의 null 여부에 암시적으로 관련되도록 설계하는 것은 피하기
api 작성시 반환 타입을 큰 객체로 만들고 반환 타입 전체가 null이거나 null이 아니게 만들어야 함.
클래스를 만들 때는 필요한 모든 값이 준비되었을 때 생성하여 null이 존재하지 않도록 하는 것이 좋다.

## item 32 유니온의 인터페이스 보다는 인터페이스의 유니온 사용하기

<!-- 음. 이친구들 벡터를 좀 많이 좋아하는 걸? -->

유니온의 인터페이스보다 인터페이스의 유니온이 좋다
-> 인터페이스 내에 여러 속성들을 유니온으로 가져가는 것보다, 하나의 타입을 만들 때 여러 인터페이스를 유니온으로 작성하는 것이 좋다.
-> 유니온 타입의 속성을 여러개 가지면 속성간의 관계가 분명하지 않을 수 있어 잠재적 버그가 많아지므로 지양해야한다.
