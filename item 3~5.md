# item 3 코드 생성과 타입이 관계없음을 이해하기

타입스크립트 컴파일러는 2가지 역할을 수행

1. 최신 타입스크립트/ 자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
2. 코드 타입의 오류를 체크

2가지 역할이 독립적으로 수행되기 때문에`타입 오류가 있는 코드도 컴파일이 가능`하고, `런타임에는 타입 체크가 불가능`하다.

- `type`이 뭐야...?  
  객체의 타입의 이름을 지정하는 방법
- `interface`가 뭐야...?  
  객체의 타입의 이름을 지정하는 또 다른 방법
- 그 2개의 차이는 뭐야?  
  interface는 선언 병합이 가능하지만 type은 그렇지 않음  
  computed value의 사용 - type은 가능하지만 interface는 불가능
- interface는 객체에만 사용이 가능하다.

p.15 instanceof 체크는 런타임에 일어나지만, Rectangle은 타입이기 때문에 런타임 시점에 아무런 역할을 할 수 없다. 타입스크립트의 타입은 `제거가능`하다. ??

p.16 타입과 값을 둘다 사용하려면 타입을 클래스로 만들면 된다?

- 타입 연산은 런타임에 영향을 주지 않는다.
- 런타임 타입은 선언된 타입과 다를 수 있다

p.19 /light를 요청하면 그 결과로 LightApiResponse를 반환하라고 선언햇지만 실제로 그렇게 되리라는 보장은 없다. API를 잘못 파악해서 ligthSwitch Value가 실제로는 문자열이었다면 런타임에는 setLightSwitch함수까지 전달될 것.(??)

- 타입스크립트 타입으로는 함수를 오버로드할 수 없다.
  -> 타입스크립트가 함수 오버로딩 기능을 지원하기는 하지만, 온전히 타입 수준에서만 동작. 하나의 함수에 대해 여러개의 선언문을 작성할 수 잇지만 구현체는 오직 하나뿐

- 타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.

p.20 `빌드타임` 오버헤드란 무엇인가?  
오버헤드가 터지면 빌드도구에서 트랜스파일만을 설정하여 타입체크를 건너 뛸 수 있다.
타입스크립트가 컴파일하는 코드는 `오래된 런타임 환경을 지원하기 위해 호환성을 높이고 성능 오버헤드를 감안`할지, `호환성을 포기하고 성능 중심의 네이티브 구현체를 선택`할지 문제에 맞닥뜨릴 수도 있다.

# item 4 구조적 타이핑에 익숙해지기

javascript는 `덕 타이핑(duck typing)`기반이다.

타입은 봉인되어있지 않다.?? -> 오픈되어있다.

클래스도 구조적 타이핑 규칙을 따른다. 클래스의 인스턴스가 예상과 다를 수 있다.

구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있다.?

p.26 모킹 라이브러리??
가상이 아닌 가짜 데이터, 실제로 존재하지는 않ㄴ으나 의미없는 데이터를 넣어 실제로 구현하는지 추적 등이 가능하게. 샘플이 있어야 만드릭 쉬우니까.

p.26 라이브러리 간의 의존성을 분리한다는 것이 무엇인가?

    의존성은
    그냥 책떠나서 말씀드리자면
    만약애 애한이 만든 나무막대기가 있다
    이 나무막대기가 라이브러리에요
    그럼 꽁치가 어떤걸 만들려고해
    망치를 만들어요
    나무막대기에다가 쇠를달아요
    그럼 망치가되잖아요
    그럼 망치는 나무막대기에 의존한다
    갑자기 나무가 썩어버리면
    그쵸
    나무가 썩었다고칩시다
    그럼 망치로 쓸수있나요
    이게 의존성입니다

# item 5 any타입 지양하기

타입스크립트의 타입시스템은 점진적이고 선택적.

타입을 조금씩 추가할 수 있기 때문에 점진적이고, 언제든지 타입체커를 해제할 수 있기 때문에 선택적.

1. any 타입에는 안전성이 없다.
2. any는 함수 시그니처를 무시해버린다
3. any 타입에는 언어서비스가 적용되지 않는다
4. any타입은 코드 리팩터링 때 버그를 감춘다.
5. any 타입 설계를 감춰버린다
6. any는 타입 시스템의 신뢰도를 떨어뜨린다.

그러므로 최대한 사용을 피하자.
