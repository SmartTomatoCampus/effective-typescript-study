# 뽀또

## 아이템 33

string 타입보다 더 구체적인 타입 사용하기

string 타입의 범위는 매우 넓기때문에 더 좁은 타입이 있는지 적절한게 있는지 확인을 해봐야 한다.

타입을 더 좁히기 위해서 하나의 타입을 공유한 뒤, 유니온 타입을 통해 타입을 좁힐 수 있지만, enum을 사용할 수도 있지만 추천하는 방향은 아니다.

### 구체적인 타입을 사용하게 되면 좋은점 3가지.

1. 타입을 명시적으로 정의함으로써 다른 곳으로 값이 전달되어도 타입 정보가 유지된다.
2. 타입을 명시적으로 정의하고 해당 타입의 의미를 설명하는 주석을 붙여 넣을 수 있다. ( 호버되면 뜨게되는 내용)
3. keyof 연산자로 더욱 세밀하게 객체의 속성 체크가 가능하다.

```tsx
T[keyof T] 는 객체 내의 가능한 모든 값의 타입이다.
```

문자열이 여러개 있거나, 확실한 문자열이라면, 문자열 리터럴을 사용해서 유니온 타입으로 지정하고 이를 string이 아닌 keyof T를 이용해 타입을 구체적으로 적용시키자 . 이말인듯 하다.

- 문자열을 남발되어 선언된 코드를 피하자.
- 모든 문자열을 할당할 수 있는 string 타입보다는 더 구체적인 타입을 사용하는 것이 좋다.
- 변수의 범위를 보다 정확하게 표현하고 싶다면 문자열 리터럴 타입의 유니온을 사용해라.
- 객체의 속성 이름의 함수 매개변수로 받을 때는 string 보다 keyof T를 사용해라.

# 너두

## 아이템 33 string 타입보다 더 구체적인 타입 사용하기

- string타입이 남용된 코드를 문자열을 남발하여 선언 이라고 표현한다
- 더자세하게 들어갈 문자인 ‘studio’|’live’ 두개의 유니온 타입으로 정의할수있음
enum은 일반적으로 추천하지 않는다고 한다
- 제너릭을 사용하더라도 string으로 출력되면 범위가 너무 넓으므로 keyof를 사용하여 범위를좁힌다
- 매개변수 타입이 정밀하면 자동완성을 제공한다


# 삼앵

## 아이템33 string타입보다 더 구체적인 타입 사용하기

- string  무분별하게 사용하지않기

ex) 무분별한 string 예제

interface Album { //이런식으로 무분별하게 사용하지않기
artist: string;
title: string;
relaseDate: string; //원하는 결과물 YYYY-MM-DD
recodingType: string; // live,studio 받기

}
const kindOfBlue: Album= { //모든값을 문자열로 가져옴
 artist: 'Miles Davis',
 title: 'Kind of Blue',
 releaseDate: 'August 17th, 1959', //date를 기대했지만 문자열이넘어옴
 recordingType: 'Studio'// live와 studio를 기대했지만 대문자Studio가 넘어옴 
};


relaseDate: Date; //날짜는 형식으로 Date형식으로 해서 명확하게 받는것이 좋다
recodingType: RecordingType;


- 변수의 범위를 보다 정확하게 표현하고 싶다면 string타입 보다는 문자열 리터럴 타입의 유니온을 사용하자
- 객체의 속성 이름을 함수 매개변수로 받을 때는 string보다 key of T를 사용하는 것이 좋습니다.
